import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as u,c as o,b as l,d as i,e as n,f as e}from"./app-a0ba2b3f.js";const c={},p=e('<h1 id="多线程与并发" tabindex="-1"><a class="header-anchor" href="#多线程与并发" aria-hidden="true">#</a> 多线程与并发</h1><h2 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h2><ul><li><p>线程的实现的几种方法</p><ul><li>继承Thread</li><li>实现Runable或Callable</li><li>从线程池获取</li></ul></li><li><p>线程的状态</p><ul><li>NEW新建状态</li><li>RUNNABLE运行状态：包括就绪的线程和运行中的线程都处于这种状态</li><li>BLOCKED阻塞： 被阻塞于锁</li><li>WATING等待 线程中调用Object.wait()方法进入，需要被唤醒</li><li>TIME-WAITING 超时等待：等待指定时间后自行返回</li><li>TERMINATED 表示该线程已经执行完毕</li></ul><figure><img src="https://secure2.wostatic.cn/static/5CB7QzMg9a9MtbydTQZuU6/image.png?auth_key=1691505269-6aWM6A1rBZuU1DzNdjTXCh-0-6762c69d9711a0ca9898fbd697cc9eb2" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>BLOCKED和WAITING有什么区别</p><ul><li>BLOCKED和WAITING都是属于线程的阻塞等待状态</li><li>BLOCKED是指线程在等待监视器锁的时候的一个状态，也就是在多个线程去竞争Synchronized锁的时候，没有竞争到锁资源的线程，会被阻塞等待，而这个时候的状态叫BLOCKER.在线程整个生命周期里面，只有Synchronized同步锁的等待才会进入这个状态。</li><li>WAITING状态表示线程的等待状态，在这个状态的线程，需要等待某一个线程的特定操作才会被唤醒。我们可以使用Object.wait()，Object.join(),LockSupport.park()这样一些方法，使得线程去进入一个WAITING状态。在这个状态下，我们必须要等待特定的算法来唤醒，比如Object.notify()可以去唤醒Object.wait()等待的线程，LockSupport.unpark()可以唤醒LockSupport.park()等待的线程。</li><li>在我看来，BLOCKED和WAITING这两个状态最主要的区别有两个： <ul><li>第一个，BLOCKED是锁竞争失败之后，被动触发的状态。而WAITING是人为主动触发的状态。</li><li>第二个，处于BLOCKED状态下的一个线程，它的唤醒是自动触发的。</li></ul></li></ul></li><li><p>如何停止一个正在运行的线程</p><ul><li>stop方法，不推荐，过期方法</li><li>interrupt方法中断</li></ul></li><li><p>什么是Deamon线程？有什么用</p><ul><li>守护线程，为其他线程做通用服务，比如垃圾回收线程。</li><li>守护线程会随着主线程的销毁而销毁，而普通线程不会。</li><li>如何设置为守护线程：可以在线程start前调用setDeamon(true)</li></ul></li><li><p>Thread里的start和run有什么区别</p><ul><li>start启动新创建的线程</li><li>start内部调用run，但这和直接run是不一样，直接run只会在原来线程中调用</li></ul></li><li><p>sleep和wait有什么区别</p><ul><li>sleep属于Thread方法，而wait属于Object方法</li><li>sleep不会释放锁，wait会释放锁，需要其他线程调用notify或notifyAll才有可能被唤醒</li><li>wait需要配合锁使用，sleep不用</li></ul></li><li><p>notify和notifyAll有什么区别</p><ul><li>notify会导致死锁，notifyAll则不会</li><li>notify只能唤醒一个处于wait状态的线程，而notifyAll是唤醒所有</li><li>notify是notifyAll的一个优化，需要我们正确使用，不然会导致死锁</li></ul></li><li><p>Thread的yield的方法有什么用</p><ul><li>让掉当前线程的CPU时间片，使线程重新恢复到就绪状态</li></ul></li><li><p>为什么wait，notify，notifyAll这些方法不是在Thread类中</p><ul><li>因为java的锁是对象锁而不是线程级别的是锁</li></ul></li></ul><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h2><ul><li><p>线程池的理解</p><ul><li>线程池本质就是一种池化技术，而池化技术是一种资源复用的思想。</li><li>线程池可以减少线程的频繁创建和销毁带来的性能开销，因为线程创建会涉及到CPU上下文切换、内存分配等工作。</li><li>线程池本身会通过参数来控制线程的创建数量，这样可以避免无休止的创建线程带来的资源利用率过高的问题，起到了资源保护的作用。</li></ul></li><li><p>线程池的作用</p><ul><li>降低资源消耗，减少创建线程的开销</li><li>提高响应速度，任务无需等待线程创建就可以立即执行</li><li>方便对线程资源的管理</li></ul></li><li><p>线程池的核心参数</p><ul><li>corePoolSize 核心线程数</li><li>maxPoolSize 最大线程数</li><li>keepAliveTime 存活时间</li><li>TimeUnit 时间单位</li><li>阻塞队列</li><li>线程工程</li><li>拒绝策略handler</li></ul></li><li><p>常用的线程池有哪些</p><ul><li>SingleThreadExecutor 单例线程池</li><li>FixedThreadPool 固定大小线程池</li><li>CachedThreadPool 可缓存线程池</li><li>ScheduledThreadPool 能定时或周期性执行任务</li></ul></li><li><p>线程池核心线程数怎么设置</p><ul><li>cpu密集型 CPU+1 ,+1是为了避免CPU处于空闲状态</li><li>IO 密集型 CPU*2</li></ul></li><li><p>提交一个新任务给线程池，具体的执行流程</p><ul><li>小于核心线程池，创建一个线程池</li><li>大于核心线程池，阻塞队列没满，入队列</li><li>队列满，小于最大线程数，创建一个线程</li><li>大于最大线程池数，使用拒绝策略</li></ul></li><li><p>线程池的拒绝策略</p><ul><li>AbortPolicy 直接丢任务，抛异常，默认</li><li>CallerRunsPolicy 用调用者所在线程来处理</li><li>DiscardOldestPolicy 丢弃队列的老任务，并执行当前任务</li><li>DiscardPolicy 直接丢弃，不抛异常</li></ul></li><li><p>线程池的submit和excute有什么区别</p><ul><li>excute返回void，接口是Executor</li><li>submit 返回 Future对象，接口是ExecutorService，是Executor的子接口</li></ul></li><li><p>线程池的状态</p><ul><li>RUNNING 线程池一旦被创建就属于这个状态，能够接收任务</li><li>SHUTDOWN 调用shutdow()方法进入这个状态，不接收新任务，但能处理队列的任务</li><li>STOP 调用shutdowNow()方法进入这个状态，不接收新任务，也不处理队列任务，且会中断正在处理的业务</li><li>TIDYING SHUTDOWN状态下，且当所有任务终止，会进入到TIDYING,并会执行terminated()钩子函数，terminated()在ThreadPoolExecutor类是空的，必要的话可以自己重载。</li><li>TERMINATED 线程池彻底终止之后，就会进入该状态</li></ul></li><li><p>线程池里线程的回收</p><ul><li>线程池里面分为核心线程和非核心线程，核心线程是常驻在线程池里面的工作线程，它有两种方式来初始化：第一种，是向线程池提交任务，被动的初始化。第二种，主动调用prestartAllCoreThreads方法。</li><li>当线程池的阻塞队列满的情况下，为了增加线程池的任务处理能力，线程池会增加非核心线程，由于非核心线程是在为了解决任务过多的情况的，当任务处理完成以后，工作线程处于空闲状态的时候，就需要进行回收。因为所有工作线程都是从阻塞队列获取要执行的任务，所以在一定时间内，阻塞队列没有任务处理的情况，那么这个任务就可以结束了。而这个功能是通过阻塞队列的Poll方法。这个方法提供了超时时间和超时单位这两个参数。当前线程在指定的时间，没有从阻塞队列里面获取任务的时候，那么Poll方法会返回null，从而去终止当前线程。</li><li>默认情况下，线程池只会回收非核心线程，如果我们希望核心线程也能回收，那么要设置参数allowCoreThreadTimeOut为true就可以了。一般我们不会去终止核心线程，因为线程池的目的本身就是为了实现线程的复用。</li></ul></li></ul><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h2><ul><li><p>说说synchronized</p><ul><li>synchronized是阻塞锁，是java的关键字，底层需要由JVM实现。 <ul><li>Synchronized经过编译，会在同步块的前后加上monitorenter和monitorexit这两个字节码指令。 <ul><li>执行monitorenter的时候，首先会尝试获取对象锁，当线程已经拥有锁，计数器+1。</li><li>在执行monitorexit的时候，会将锁计数器减1，直至为0，代表锁被释放了。</li></ul></li><li>Synchronized修饰方法时，方法会有个ACC_SYNCHRONIZED ，当某个线程访问方法时候会检查该方法是否有这个标志，有的话需要先获取monitor锁，才能执行方法，执行完后释放monitor锁。</li></ul></li></ul></li><li><p>synchronized虽然不能禁止指令重排，但是保证了有序性</p><ul><li>首先需要讲一下有序性相对的无序性： <ul><li>如果在一个线程观察到另一个线程，所有操作都是无序的，指的是&quot;指令重排序&quot;和&quot;工作内存与主内存同步延迟&quot;现象。</li><li>指令重排JVM层对程序的优化措施。</li></ul></li><li>synchronized保证了有序性，因为线程与线程之间，每一个synchronized代码块都是原子性操作，它能保证每个时刻只有一个线程能执行同步代码块，解决了工作内存和主内存的同步延迟问题。</li></ul></li><li><p>说说怎么使用synchronized</p><ul><li>修饰实例方法，给对象实例加锁，进入同步块前要获得锁</li><li>修饰静态方法，给类加锁，类锁与实例锁不冲突</li><li>修饰代码块，给指定对象加锁，进入同步块的时候要获得给定对象的锁</li></ul></li><li><p>synchronize和ReentrantLock的区别</p><ul><li>相同点：可重入锁</li><li>不同点： <ul><li>synchronized是关键字，ReentrantLock是类</li><li>synchronized不需要手动加锁和释放锁，ReentrantLock需要</li><li>ReentrantLock提供更多的功能： <ul><li>公平锁，构造函数有个标志位可以让锁变成公平锁</li><li>等待可中断，持有锁对象长期不释放，正在等待的线程可以放弃等待</li><li>锁可以绑定多个条件，一个ReentrantLock可以绑定多个对象</li></ul></li></ul></li></ul></li><li><p>volatile关键字有什么用</p><ul><li>保证了可见性，记一个线程操作了变量，那么其他线程的就会知道，然后从主内存更新下自己的工作内存</li><li>禁止指令重排序</li></ul></li><li><p>volatile的禁止指令重排</p><ul><li>x=0 //指令1</li><li>y=1 //指令2</li><li>volatile flag = false //指令3</li><li>x=2 //指令4</li><li>y=3 //指令5</li><li>因为flag是禁止指令重排，所有指令3不可能被重排到1-2之前，也不可能重排到4-5之后</li></ul></li><li><p>为什么要指令重排</p><ul><li>因为指令重排可以加快速度</li><li>比如上面的5个命令</li><li>重排后，可以把x的两个赋值操作放到一起，可以合并操作，比如x=0，x=1，放到一起执行，要比分割开多次执行速度快</li></ul></li><li><p>volatile为什么不是线程安全的</p><ul><li>因为volatile只是保证了可见性</li><li>volatile具有禁止指令重排的功能，保证了顺序性</li><li>但是volatile并不能保证原子性，所有是线程不安全的</li></ul></li><li><p>volatile和synchronized的区别</p><ul><li>都保证可见性，但synchronized还保证了原子性</li><li>volatile 只能修饰变量，synchronized能修饰变量，方法，类方法</li><li>volatile 不会造成线程阻塞，synchronized会阻塞线程</li><li>volatie 不会被编译器优化，而synchronized会被编译器优化</li></ul></li><li><p>死锁产生的四个条件</p><ul><li>互斥条件：一个资源只能被一个线程使用</li><li>请求与保持条件：一个线程对于请求资源被阻塞的时候，要保持持有的资源不放</li><li>不剥夺条件：线程已获得到的资源不能被强行剥夺</li><li>循环等待条件：若干线程之间形成一种头尾相接的的循环等待资源关系</li><li>只要发生死锁，必然满足以上四个条件，避免死锁的原则就是打破其中一个条件</li></ul></li><li><p>如何避免死锁</p><ul><li>指定获取锁的顺序</li><li>如某个线程只有在获取A锁和B锁才能对某资源进行操作，那么可以规定，只有在获取A锁的条件下才能获取B锁</li></ul></li><li><p>如何检测死锁</p><ul><li>为每个资源和线程分配一个id，然后建立资源分配表和进程等待表</li></ul></li><li><p>活锁</p><ul><li>举例子：死锁如果是两个不动的轮子，活锁大概就是在路上碰到一个美女，你向右跨了一步，美女也正好向左跨了一步，不断循环，最后谁都过不去。</li></ul></li><li><p>乐观锁和悲观锁+实现方式</p><ul><li>乐观锁： <ul><li>每次操作都认为不会发生冲突，只是提交更新的时候做一次资源是否发生改变的检测。</li><li>实现方式：CAS 或者 加版本号</li></ul></li><li>悲观锁： <ul><li>每次操作都认为会发生冲突，操作的时候就上锁，操作完就解锁。</li><li>实现方式：锁机制</li></ul></li></ul></li><li><p>锁优化机制（锁升级）</p><ul><li>JDK 1.6 中，对Synchronized的优化有哪些</li><li>JDK1.6后，官方优化了synchronize，使用的机制包括有：自旋锁，自适应自旋锁，锁消除，锁粗化，轻量级锁，偏向锁 <ul><li>自旋锁（JDK4就有，默认关闭，JDK6默认开启） <ul><li>线程上下文切换是一个开销比较大的工作，在多核多线程时代，当前线程获得了cpu资源，但是在等待于一个锁，该锁被其他线程占用，那么就等待一会儿，看看锁能不能被释放。当然等待是有限度的，默认是自旋10次，如果还没获得锁，那么就放弃该线程的cpu资源。</li></ul></li><li>自适应自旋锁 <ul><li>自旋锁，等待的锁可能一直被其他线程占用导致自旋失败，所以就出现了自适应自旋锁。</li><li>自适应这个词，听起来就很智能，事实也是如此。 <ul><li>当一个锁对象被其他线程占用，那么等待的线程自旋后成功获得了锁，那么JVM会认为下次大概率也会成功，会把自旋等到的次数调大。反之，很可能不自旋。</li><li>随着JVM的运行时长越长，JVM监控得到的数据会越多，那么也会越智能。</li></ul></li></ul></li><li>锁清除 <ul><li>即时编译编译运行时，如果代码写了锁，但是发现不存在共享变量的竞争，那么就会消除锁。</li></ul></li><li>锁粗化 <ul><li>如果代码中，锁的是同一个锁对象，然而，代码上又反复加锁释放锁，那么JVM就会把锁的粒度调大一点。</li></ul></li><li>轻量级锁 <ul><li>就是CAS</li><li>有一个经验法则，“对于绝大部分锁，在整个同步周期内是不存在竞争的”，有了轻量级锁，那么就可以避免用互斥量这种偏重的锁。</li></ul></li><li>偏向锁 <ul><li>偏向锁，连CAS都不操作了，他偏向于第一个获取他的线程，如果接下来的时间里，其他线程没有获取该锁，下次该线程获取该锁的时候大概率也不会锁竞争，那么就直接不加锁了，连CAS操作都不要了。</li></ul></li></ul></li></ul></li><li><p>调用wait方法的锁一定是重量级锁么</p><ul><li>是的，只有重量级锁才会有ObjectMonitor对象，而ObjectMonitor对象里有WaitSet集合，WaitSet保存处于Waiting状态的线程</li></ul></li></ul><h2 id="cas" tabindex="-1"><a class="header-anchor" href="#cas" aria-hidden="true">#</a> CAS</h2><ul><li>CAS原理 <ul><li>CAS叫做CompareAndSwap，中文叫比较和交换。</li><li>通过三个操作数，来保证原子性： <ul><li>变量的地址，V表示</li><li>旧值，A表示</li><li>新值，B表示</li></ul></li><li>执行CAS的时候，只有当V=A的时候，才会用B去更新V</li></ul></li><li>CAS的缺点 <ul><li>ABA问题：读的时候是A，然后准备赋值的时候仍然是A。但是有可能这个过程中值可能被改为B，然后又被改回A</li><li>循环开销时间大：自旋CAS的方式如果长时间不成功，会给CPU带来很大消耗</li><li>只能保证一个共享变量的原子性：多个的话通过AtomicReference来处理或者加锁</li></ul></li></ul><h2 id="aqs" tabindex="-1"><a class="header-anchor" href="#aqs" aria-hidden="true">#</a> AQS</h2><ul><li><p>AQS</p><ul><li>AQS，全称AbstractQueuedSynchronizer，中文叫做 抽象队列同步器。</li><li>如果说juc的基础是CAS，那么AQS是整个并发包的核心ReentrantLock 、CountDownLatch、Semaphore都用到了它。</li><li>AQS 是一个锁框架，它定义了锁的实现机制，并开放出扩展的地方，让子类去实现，比如我们在 lock 的时候，AQS 开放出 state 字段，让子类可以根据 state 字段来决定是否能够获得锁，对于获取不到锁的线程 AQS 会自动进行管理，无需子类关心，这就是 lock 时锁的内部机制，封装的很好，又暴露出子类锁需要扩展的地方。</li><li>AQS 底层是由同步队列 + 条件队列联手组成，同步队列管理着获取不到锁的线程的排队和释放，条件队列是在一定场景下，对同步队列的补充，比如获得锁的线程从空队列中拿数据，肯定是拿不到数据的，这时候条件队列就会管理该线程，使该线程阻塞。</li><li>AQS 围绕两个队列，提供了四大场景，分别是：获得锁、释放锁、条件队列的阻塞，条件队列的唤醒。</li></ul></li><li><p>AQS为什么要使用双向链表</p><ul><li>双向链表有个特性，两个节点之间相互引用，上一个节点可以找到下一个，下一个节点可以找到上一个。</li><li>AQS为了满足公平锁的特性，需要实现一个队列，有一个场景，就是要唤醒第一个等待的线程和添加一个新的线程到同步队列里。如果操作同一个节点会存在一个并发问题。所以添加的过程用尾插法，唤醒的时候从头部出。</li><li>在同步队列中，队列存放的是阻塞的线程，而线程有时候会死亡。为了清理掉这些死亡的线程，需要从尾部遍历到头部。那么也需要这个双向的特性。</li></ul></li><li><p>AQS 的同步队列的数据结构</p><figure><img src="https://secure2.wostatic.cn/static/6gcWbjhQ9U6LQ2kRnM5Tjh/image.png?auth_key=1691505271-eJ7PPPrzd5xRmG42hy8VtB-0-1868c9765945d55d5c08c4f3c16d8012" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>当同步状态state修改为1失败后，AQS会把当前线程封装成一个Node节点放到队列尾部，并阻塞当前线程</li><li>同步状态state为0时，AQS会唤醒队列的第一个线程节点，让其获取同步状态置state为1</li></ul></li><li><p>AQS对资源的共享方式</p><ul><li>Exclusive（独占式），只有一个线程能执行。如ReentrantLock，可分为公平锁和非公平锁。 <ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li>Share（共享式）：多个线程可同时执行，如Semaphore/CountDownLatch、 CyclicBarrier、ReadWriteLock</li></ul></li></ul><h2 id="并发工具类" tabindex="-1"><a class="header-anchor" href="#并发工具类" aria-hidden="true">#</a> 并发工具类</h2>',12),h=l("li",null,[l("p",null,"了解Semaphore吗"),l("ul",null,[l("li",null,"Semaphore是一个信号量，作用是限制某段代码的并发数"),l("li",null,"有一个构造函数，参数为 n，表示最多只有n个线程访问该代码块。超过n个的话，只能等待某个线程执行完毕，下一个线程再进入这个代码块。"),l("li",null,"当n传入1的时候，Semaphore相当于Synchronize了")])],-1),d=l("li",null,[l("p",null,"CountDownLatch"),l("ul",null,[l("li",null,[i("CountDownLatch有一个构造方法：CountDownLatch（int n），传入一个参数，主线程调用await方法，进入阻塞状态，等待CountDownLatch对象在其他线程执行countdown()方法直到n为0为止，主线程才会执行下一步。 "),l("ul",null,[l("li",null,"CountDownLatch就是等待其他线程执行完成，必要时候可以完成对线程的汇总操作。")])])])],-1),s=l("p",null,"CyclicBarrier",-1),A={href:"https://www.jianshu.com/p/424374d71b67",target:"_blank",rel:"noopener noreferrer"},T=l("li",null,[i("是什么？ "),l("ul",null,[l("li",null,"CyclicBarrier是同步屏障，JDK1.5被引入，可以让一组线程达到一个屏障的时候被阻塞，直到最后一个线程被阻塞的时候，所有线程才开始执行。")])],-1),y=l("li",null,[i("两个构造函数： "),l("ul",null,[l("li",null,"CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达屏障位置，线程被阻塞。"),l("li",null,"CyclicBarrier(int parties, Runnable barrierAction)，其中barrierAction会在所有线程到达屏障后执行。")])],-1),L=e("<li><p>说说CyclicBarrier和CountDownLatch的区别？</p><ul><li>首先讲一下他们的作用</li><li>区别： <ul><li>CountDownLatch，当计数器为0的时候，CountDownLatch就不能再被使用了，而CyclicBarrier可以被重用</li><li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</li></ul></li></ul></li><li><p>ThreadLocal</p><p>原理：<br> - ThreadLocal存放的是线程共享变量，内部有一个静态内部类ThreadLocalMap，key是ThreadLocal，vaue是要存放的值<br> - ThreadLocal.get(): ThreadLocal有一个方法getMap(Thread.currentThread) 得到ThreadLocalMap，ThreadLocalMap.get(ThreadLocal)， 返回线程私有value值<br> - ThreadLocal.set(): 还是先得到当前线程的ThreadLocalMap，然后ThreadLocalMap.set(ThreadLocal,value)</p><ul><li>ThreadLocal、ThreadLocalMap、currentThread的关系： <ul><li>每个线程都有一个ThreadLocalMap，通过ThreadLocalMap.get(ThreadLocal)能得到当前线程存放的值</li></ul></li><li>缺点： <ul><li>内存泄漏： <ul><li>ThreadLocalMap的key是ThreadLocal，是弱引用，下次GC会被回收，而value是强引用，没法被GC回收，可能产生内存泄漏问题</li><li>解决方案： <ul><li>使用完ThreadLocal的时候，记得调用remove()方法</li></ul></li></ul></li><li>对于线程池，由于线程池也会重用Thread对象，与Thread绑定的ThreadLcoalMap会被重用，造成一系列的问题。</li></ul></li><li>有很多⼈说建议把ThreadLocal修饰为static，为什么？ <ul><li>ThreadLocal能实现了线程的数据隔离，不在于它⾃⼰本身，⽽在于Thread的ThreadLocalMap</li><li>所以，ThreadLocal可以只初始化⼀次，只分配⼀块存储空间就⾜以了，没必要作为成员变量多次被初始化。</li></ul></li></ul></li><li><p>happen-before 中文叫先行并发</p><ul><li>用于判断数据是否存在竞争，线程是否安全的一个手段</li><li>happen-before是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，那么就可以说在发生操作B之前，操作A产生的影响能被操作B观察到 <ul><li>影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等</li></ul></li></ul></li>",3),C=e('<figure><img src="https://cdn.nlark.com/yuque/0/2022/png/652151/1656146009322-073425d9-7bf1-494c-b9ca-46a1fc60f13a.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="原子类" tabindex="-1"><a class="header-anchor" href="#原子类" aria-hidden="true">#</a> 原子类</h2><ul><li><p>原子类有哪些</p><ul><li>基本类型： <ul><li>AtomicInteger ： 整型原子类</li><li>AtomicLong： 长整型原子类</li><li>AtomicBoolean： 布尔型原子类</li></ul></li><li>数组类型 <ul><li>AtomicIntegerArray： 整型数组原子类</li><li>AtomicLongArray： 长整型数组原子类</li><li>AtomicReferenceArray： 引用类型数组原子类</li></ul></li><li>引用类型： <ul><li>AtomicReference： 引用类型原子类</li><li>AtomicStampedReference： 原子更新带有版本号的引用类型。该类将整型数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference： 原子更新带有标记位的引用类型。<strong>对象属性修改类型</strong></li><li>AtomicIntegerFieldUpdater： 原子更新整型字段的更新器</li><li>AtomicLongFieldUpdater： 原子更新长整型字段的更新器</li><li>AtomicMarkableReference： 原子更新带有标记位的引用类型</li></ul></li></ul></li><li><p>AtomicInteger原理</p><ul><li>通过CAS和 volatile 来保证原子性。从而避免 synchronized 的高开销，执行效率大为提升。</li></ul></li></ul>',3);function f(S,m){const a=r("ExternalLinkIcon");return u(),o("div",null,[p,l("ul",null,[h,d,l("li",null,[s,l("ul",null,[l("li",null,[l("a",A,[i("https://www.jianshu.com/p/424374d71b67"),n(a)])]),T,y])]),L]),C])}const _=t(c,[["render",f],["__file","多线程与并发.html.vue"]]);export{_ as default};
