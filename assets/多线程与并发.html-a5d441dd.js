const t=JSON.parse('{"key":"v-5198a385","path":"/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91.html","title":"多线程与并发","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-08-08T00:00:00.000Z","category":["java"],"tag":["多线程","高并发"],"description":"多线程与并发 线程 线程的实现的几种方法 继承Thread 实现Runable或Callable 从线程池获取 线程的状态 NEW新建状态 RUNNABLE运行状态：包括就绪的线程和运行中的线程都处于这种状态 BLOCKED阻塞： 被阻塞于锁 WATING等待 线程中调用Object.wait()方法进入，需要被唤醒 TIME-WAITING 超时等待：等待指定时间后自行返回 TERMINATED 表示该线程已经执行完毕 BLOCKED和WAITING有什么区别 BLOCKED和WAITING都是属于线程的阻塞等待状态 BLOCKED是指线程在等待监视器锁的时候的一个状态，也就是在多个线程去竞争Synchronized锁的时候，没有竞争到锁资源的线程，会被阻塞等待，而这个时候的状态叫BLOCKER.在线程整个生命周期里面，只有Synchronized同步锁的等待才会进入这个状态。 WAITING状态表示线程的等待状态，在这个状态的线程，需要等待某一个线程的特定操作才会被唤醒。我们可以使用Object.wait()，Object.join(),LockSupport.park()这样一些方法，使得线程去进入一个WAITING状态。在这个状态下，我们必须要等待特定的算法来唤醒，比如Object.notify()可以去唤醒Object.wait()等待的线程，LockSupport.unpark()可以唤醒LockSupport.park()等待的线程。 在我看来，BLOCKED和WAITING这两个状态最主要的区别有两个： 第一个，BLOCKED是锁竞争失败之后，被动触发的状态。而WAITING是人为主动触发的状态。 第二个，处于BLOCKED状态下的一个线程，它的唤醒是自动触发的。 如何停止一个正在运行的线程 stop方法，不推荐，过期方法 interrupt方法中断 什么是Deamon线程？有什么用 守护线程，为其他线程做通用服务，比如垃圾回收线程。 守护线程会随着主线程的销毁而销毁，而普通线程不会。 如何设置为守护线程：可以在线程start前调用setDeamon(true) Thread里的start和run有什么区别 start启动新创建的线程 start内部调用run，但这和直接run是不一样，直接run只会在原来线程中调用 sleep和wait有什么区别 sleep属于Thread方法，而wait属于Object方法 sleep不会释放锁，wait会释放锁，需要其他线程调用notify或notifyAll才有可能被唤醒 wait需要配合锁使用，sleep不用 notify和notifyAll有什么区别 notify会导致死锁，notifyAll则不会 notify只能唤醒一个处于wait状态的线程，而notifyAll是唤醒所有 notify是notifyAll的一个优化，需要我们正确使用，不然会导致死锁 Thread的yield的方法有什么用 让掉当前线程的CPU时间片，使线程重新恢复到就绪状态 为什么wait，notify，notifyAll这些方法不是在Thread类中 因为java的锁是对象锁而不是线程级别的是锁","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91.html"}],["meta",{"property":"og:site_name","content":"BlueSky的八股文"}],["meta",{"property":"og:title","content":"多线程与并发"}],["meta",{"property":"og:description","content":"多线程与并发 线程 线程的实现的几种方法 继承Thread 实现Runable或Callable 从线程池获取 线程的状态 NEW新建状态 RUNNABLE运行状态：包括就绪的线程和运行中的线程都处于这种状态 BLOCKED阻塞： 被阻塞于锁 WATING等待 线程中调用Object.wait()方法进入，需要被唤醒 TIME-WAITING 超时等待：等待指定时间后自行返回 TERMINATED 表示该线程已经执行完毕 BLOCKED和WAITING有什么区别 BLOCKED和WAITING都是属于线程的阻塞等待状态 BLOCKED是指线程在等待监视器锁的时候的一个状态，也就是在多个线程去竞争Synchronized锁的时候，没有竞争到锁资源的线程，会被阻塞等待，而这个时候的状态叫BLOCKER.在线程整个生命周期里面，只有Synchronized同步锁的等待才会进入这个状态。 WAITING状态表示线程的等待状态，在这个状态的线程，需要等待某一个线程的特定操作才会被唤醒。我们可以使用Object.wait()，Object.join(),LockSupport.park()这样一些方法，使得线程去进入一个WAITING状态。在这个状态下，我们必须要等待特定的算法来唤醒，比如Object.notify()可以去唤醒Object.wait()等待的线程，LockSupport.unpark()可以唤醒LockSupport.park()等待的线程。 在我看来，BLOCKED和WAITING这两个状态最主要的区别有两个： 第一个，BLOCKED是锁竞争失败之后，被动触发的状态。而WAITING是人为主动触发的状态。 第二个，处于BLOCKED状态下的一个线程，它的唤醒是自动触发的。 如何停止一个正在运行的线程 stop方法，不推荐，过期方法 interrupt方法中断 什么是Deamon线程？有什么用 守护线程，为其他线程做通用服务，比如垃圾回收线程。 守护线程会随着主线程的销毁而销毁，而普通线程不会。 如何设置为守护线程：可以在线程start前调用setDeamon(true) Thread里的start和run有什么区别 start启动新创建的线程 start内部调用run，但这和直接run是不一样，直接run只会在原来线程中调用 sleep和wait有什么区别 sleep属于Thread方法，而wait属于Object方法 sleep不会释放锁，wait会释放锁，需要其他线程调用notify或notifyAll才有可能被唤醒 wait需要配合锁使用，sleep不用 notify和notifyAll有什么区别 notify会导致死锁，notifyAll则不会 notify只能唤醒一个处于wait状态的线程，而notifyAll是唤醒所有 notify是notifyAll的一个优化，需要我们正确使用，不然会导致死锁 Thread的yield的方法有什么用 让掉当前线程的CPU时间片，使线程重新恢复到就绪状态 为什么wait，notify，notifyAll这些方法不是在Thread类中 因为java的锁是对象锁而不是线程级别的是锁"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"blueSky"}],["meta",{"property":"article:tag","content":"多线程"}],["meta",{"property":"article:tag","content":"高并发"}],["meta",{"property":"article:published_time","content":"2023-08-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多线程与并发\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"blueSky\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"线程","slug":"线程","link":"#线程","children":[]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[]},{"level":2,"title":"锁","slug":"锁","link":"#锁","children":[]},{"level":2,"title":"CAS","slug":"cas","link":"#cas","children":[]},{"level":2,"title":"AQS","slug":"aqs","link":"#aqs","children":[]},{"level":2,"title":"并发工具类","slug":"并发工具类","link":"#并发工具类","children":[]},{"level":2,"title":"原子类","slug":"原子类","link":"#原子类","children":[]}],"git":{},"readingTime":{"minutes":18.91,"words":5672},"filePathRelative":"java/多线程与并发.md","localizedDate":"August 8, 2023","excerpt":"<h1> 多线程与并发</h1>\\n<h2> 线程</h2>\\n<ul>\\n<li>\\n<p>线程的实现的几种方法</p>\\n<ul>\\n<li>继承Thread</li>\\n<li>实现Runable或Callable</li>\\n<li>从线程池获取</li>\\n</ul>\\n</li>\\n<li>\\n<p>线程的状态</p>\\n<ul>\\n<li>NEW新建状态</li>\\n<li>RUNNABLE运行状态：包括就绪的线程和运行中的线程都处于这种状态</li>\\n<li>BLOCKED阻塞： 被阻塞于锁</li>\\n<li>WATING等待  线程中调用Object.wait()方法进入，需要被唤醒</li>\\n<li>TIME-WAITING 超时等待：等待指定时间后自行返回</li>\\n<li>TERMINATED 表示该线程已经执行完毕</li>\\n</ul>\\n<figure><img src=\\"https://secure2.wostatic.cn/static/5CB7QzMg9a9MtbydTQZuU6/image.png?auth_key=1691505269-6aWM6A1rBZuU1DzNdjTXCh-0-6762c69d9711a0ca9898fbd697cc9eb2\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n</li>\\n<li>\\n<p>BLOCKED和WAITING有什么区别</p>\\n<ul>\\n<li>BLOCKED和WAITING都是属于线程的阻塞等待状态</li>\\n<li>BLOCKED是指线程在等待监视器锁的时候的一个状态，也就是在多个线程去竞争Synchronized锁的时候，没有竞争到锁资源的线程，会被阻塞等待，而这个时候的状态叫BLOCKER.在线程整个生命周期里面，只有Synchronized同步锁的等待才会进入这个状态。</li>\\n<li>WAITING状态表示线程的等待状态，在这个状态的线程，需要等待某一个线程的特定操作才会被唤醒。我们可以使用Object.wait()，Object.join(),LockSupport.park()这样一些方法，使得线程去进入一个WAITING状态。在这个状态下，我们必须要等待特定的算法来唤醒，比如Object.notify()可以去唤醒Object.wait()等待的线程，LockSupport.unpark()可以唤醒LockSupport.park()等待的线程。</li>\\n<li>在我看来，BLOCKED和WAITING这两个状态最主要的区别有两个：\\n<ul>\\n<li>第一个，BLOCKED是锁竞争失败之后，被动触发的状态。而WAITING是人为主动触发的状态。</li>\\n<li>第二个，处于BLOCKED状态下的一个线程，它的唤醒是自动触发的。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>如何停止一个正在运行的线程</p>\\n<ul>\\n<li>stop方法，不推荐，过期方法</li>\\n<li>interrupt方法中断</li>\\n</ul>\\n</li>\\n<li>\\n<p>什么是Deamon线程？有什么用</p>\\n<ul>\\n<li>守护线程，为其他线程做通用服务，比如垃圾回收线程。</li>\\n<li>守护线程会随着主线程的销毁而销毁，而普通线程不会。</li>\\n<li>如何设置为守护线程：可以在线程start前调用setDeamon(true)</li>\\n</ul>\\n</li>\\n<li>\\n<p>Thread里的start和run有什么区别</p>\\n<ul>\\n<li>start启动新创建的线程</li>\\n<li>start内部调用run，但这和直接run是不一样，直接run只会在原来线程中调用</li>\\n</ul>\\n</li>\\n<li>\\n<p>sleep和wait有什么区别</p>\\n<ul>\\n<li>sleep属于Thread方法，而wait属于Object方法</li>\\n<li>sleep不会释放锁，wait会释放锁，需要其他线程调用notify或notifyAll才有可能被唤醒</li>\\n<li>wait需要配合锁使用，sleep不用</li>\\n</ul>\\n</li>\\n<li>\\n<p>notify和notifyAll有什么区别</p>\\n<ul>\\n<li>notify会导致死锁，notifyAll则不会</li>\\n<li>notify只能唤醒一个处于wait状态的线程，而notifyAll是唤醒所有</li>\\n<li>notify是notifyAll的一个优化，需要我们正确使用，不然会导致死锁</li>\\n</ul>\\n</li>\\n<li>\\n<p>Thread的yield的方法有什么用</p>\\n<ul>\\n<li>让掉当前线程的CPU时间片，使线程重新恢复到就绪状态</li>\\n</ul>\\n</li>\\n<li>\\n<p>为什么wait，notify，notifyAll这些方法不是在Thread类中</p>\\n<ul>\\n<li>因为java的锁是对象锁而不是线程级别的是锁</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
