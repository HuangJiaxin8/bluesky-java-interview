const n=JSON.parse('{"key":"v-88662950","path":"/java/Spring.html","title":"Spring","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-08-08T00:00:00.000Z","category":["java"],"tag":["spring","springboot"],"description":"Spring IOC/AOP Spring的理解（IOC和AOP） 首先，spring是个庞大的项目，从官网可以看到包括了： SpringFramework SpringData SpringSecurity SpringBoot SpringCloud 当然，除了这些之外，Spring还包括很多其他的项目 Spring最主要的有两个特点是IOC和AOP IOC: IOC就是控制反转，指的是创建对象控制权的转移，以前创建对象的时候都是自己控制，现在Spring容器会根据配置文件去帮我们创建和管理对象。 好处：解耦合，对象的属性只需要在配置文件中写，不用在java代码写，把属性与java代码解耦合。 原理：使用反射机制，根据配置文件信息去创建对象。使用了工厂的设计模式。 Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。 AOP: 把公共的代码提取出来，进行封装。 减少系统代码重复量，降低模块耦合度。 原理：基于动态代理 要代理的对象实现了接口，就用JDK动态代理生成代理类。 没有实现接口，就用cglib，实现子类的方式生成代理类。 孙帅的IOC和DI IOC 控制反转 控制：对于成员变量赋值的控制权 控制反转：把成员变量赋值的控制权，从代码中反转到Spring工厂和配置文件中完成。 好处：解耦合 底层实现：反射加工厂设计模式 DI 依赖注入 当一个类需要另一个类时，就意味着依赖，一旦出现了依赖，那么就可以把另一个类作为本类的成员变量，最终通过Spring配置文件注入。 类加载器的作用 通过类加载器把对应class文件加载到JVM 通过类加载器创建类的Class对象，进而创建这个类的对象 User —&gt; user User类的Class对象 —&gt;new User() —&gt;user 如何获取类加载器：每一个.class文件，JVM会自动分配与之对应的ClassLoader 代理创建3要素（孙帅） 原始对象 额外功能 代理对象和原始对象实现相同的接口 JDK动态代理 （孙帅） Proxy.newProxyInstance(classloader,interfacce,invocationhandler) 为什么JDK动态代理中，该api需要我们传入classloader？ 创建代理类的对象需要用到类加载器 JDK动态代理没有相应的class文件，那么JVM就不会为其分配ClassLoader，所以需要我们为其指定classLoader（借用类加载器）。 Spring AOP和AspectJ 有什么区别？ AOP是运行时增强，AspectJ是编译时增强。 AOP是动态代理方式实现，AspectJ是基于ASM修改字节码。 AspectJ性能比较好，切面多的话，用AspectJ Spring切面的五种通知类型 before，前置通知，在方法调用前执行 after 方法执行后调用 around 之前之后都执行 after-returning 方法成功执行完成后执行 after-throwing 方法执行报错后执行 Autowired和Resource关键字的区别？ 共同点： 写在字段或者Setter方法上 都用于bean的注入 不同点： Autowired是Spring 提供的注解，而@Resource是javax包的注解 Autowired 是ByType来装配对象，如果想ByName可以通过配合@Qualifer使用，而@Resource默认是根据ByName来装配，如果想改为ByType，使用type属性 Spring bean 的生命周期 实例化bean：推断构造方法，实例化bean 设置对象属性（依赖注入）：实例化后的baen被封装到beanWrapper中，完成依赖注入 处理Aware接口： 如果Bean实现了BeanNameAware接口，会调用setBeanName()方法 如果实现了BeanFactoryAware接口，调用setBeanFactory()方法 BeanPostProcessor 如果bean实现了BeanPostProcessor接口，那么会调用postprocessBeforeInitialization() 初始化 如果Bean中的某个方法被@PostConstruct 标记，那么就去调用它 如果实现了InitializingBean，调用afterPropertiesSet方法 如果Bean 指定了init-method 方法，那么就去调用它。 如果Bean实现了BeanPostProcessor接口，会调用postProcessAfterInitialization() bean不再需要的时候，会被销毁，如果实现了disposableBean接口，那么就调用destory方法。 bean的作用域 singleton：默认，容器只有一个bean prototype：每个请求创建一个bean request：每个网络请求创建一个bean session：每个session创建一个bean global-session：global-session跟Portlet应用相关的 Spring中单例bean是线程安全的吗 关于单例bean的线程安全问题需要由开发者自己去控制，Spring并没有做线程安全方面的控制 Spring 基于xml注入的方式有哪些 Set方法注入 构造器注入 Spring如何解决循环依赖问题（简单版本） 对于普通Java对象，对象之间的依赖问题很好解决，比如X依赖Y，Y依赖X。 X x= new X(); x.setY (); Y y=new Y();y.setX() 由于Spring bean 有着复杂的生命周期，所以解决循环依赖问题也稍微麻烦一点，主要影响的是 实例化 填充属性 初始化 Spring 使用了三级缓存来解决循环依赖的问题 singletonObjects 用于存放可以直接使用的单例bean earlySingletonObjects 用于存放没填充属性的bean singletonFactories 存放bean工厂 对于对象A依赖B，对象B依赖A的情况 在对象A实例化后，会提前暴露到earlySingletonObjects 接着填充属性，发现此时依赖了B，发现没有B，走B的创建过程 B实例化后，填充属性，发现依赖了A，从earlySingletonObjects 中获取到了未填充属性的A，设置A，完成初始化后把自己放到singletonObjects里 返回A继续填充B，发现B已经在singletonObjects里面了，直接填充B 解决了循环依赖问题 前面有提到三级缓存，三级缓存的作用是什么？ 三级缓存是用来存储代理 Bean，当调用 getBean()方法时，发现目标 Bean 需要通过代理工厂来创建，此时会将创建好的实例保存到三级缓存，最终也会将赋值好的 Bean 同步到一级缓存中。 Spring 中哪些情况下，不能解决循环依赖问题？ 多例 Bean 通过 setter 注入的情况，不能解决循环依赖问题 构造器注入的 Bean 的情况，不能解决循环依赖问题 单例的代理 Bean 通过 Setter 注入的情况，不能解决循环依赖问题 设置了@DependsOn 的 Bean 的情况，不能解决循环依赖问 Spring的循环依赖（子路老师https://www.bilibili.com/video/BV1Ga4y1E7Br） 对于普通的Java对象的循环依赖问题，他们之间是很好解决的，比如X依赖Y，Y依赖X，这种是很好解决的： X x= new X(); x.setY (); Y y=new Y();y.setX() Spring的循环依赖之所以复杂，是因为Spring Bean有着不同于普通Java对象的复杂生命周期，所以要讲一下Spring Bean的生命周期 首先Spring 容器启动后，他会去做一个扫描，扫描之后把他变成BeanDefinition存到一个BeanDefinitionMap中 然后对这个Map去遍历，并做验证，比如验证是否单例，是否懒加载，是否有depend on，是否抽象等等。 然后获取当前实例化的类有没有存在单例池中，有没有被提前暴露。如果没有被提前暴露的话，Spring Bean就会被开始创建。 通过推断构造方法，推断出一个最佳的构造方法，然后通过反射去实例化Java对象 判断是否做BeanDefinition的合并，Spring容器是否支持循环依赖，如果支持循环依赖的话，会提前暴露一个半成品的Bean到ObjectFactory，存到一个二级缓存Map中。 做一些属性填充 做一些Aware接口的回调，比如BeanNameAware，ApplicationContextAware，ClassLoaderAware等等。 如果实现了PostProcessor接口的话，就做初始化之前的方法回调。 然后做一些初始化的回调，@PostConstruct，InitializingBean，或者init-method方法。 如果实现了PostProcessor接口的话，就做初始化之后的方法回调。 这样的话，整个Spring Bean基本可以满足使用了。把这个Bean放入到单例池。 Spring的循环依赖解决大概： 实例化X的时候，首先对X做一些基本的验证，验证完之后，看一下X所对应的ObjectFactory有没有提前暴露，这种时候肯定是没有的 ，接着就推断构造方法。接着就把X实例化出来，X实例化出来就会提前暴露。接着就是X的属性填充，发现了需要填充Y。 发现Y并没有被实例化，走Y的生命周期过程，发现Y也没有提前暴露，继续走实例化Y，实例化Y后继续往下执行，把Y提前暴露。接着做Y的属性填充，发现需要填充X，但是X并没有在单例池中（X实例化只是走了一半）。 继续走X的生命周期流程，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;解决循环依赖。 Spring 实例化Bean推断构造方法 如果@Autowired指定了构造方法，那么就使用该构造方法 如果没有指定 优先使用无参构造 如果没有无参构造方法，有两个及以上的构造方法，会报错 Spring事务实现方式 编程事务 声明式事务@Transcation Spring事务的传播级别（7个） PROPAGATION_REQUIRED：默认的Spring事务传播级别，若当前存在事务就加入事务，没有就创建一个 PAOPAGATION_REQUIRE_NEW：不管有没有事务都新建一个，新老事务相互独立 PROPAGATION_SUPPORTS：当前存在事务，就加入其中，没有事务就不走事务 PROPAGATION_NOT_SUPPORTED：以非事务的方式运行，存在事务就先把事务挂起 PROPAGATION_MANDATORY：强制事务执行，若当前不存在，则抛出异常 PROPAGATION_NEVER: 以非事务的方式执行，如果当前存在事务，则抛出异常 PROPAGATION_NESTED：存在事务，嵌套其中，没有事务，创建一个 Spring 事务失效的原因 数据库存储引擎不支持事务 异常被捕获，没有抛出异常 异常类型错误，默认是RuntimeExcetion 注解所在的方法不是public 事务类没有被spring容器管理 事务属性配置不正确，propagation属性配置为不适用事务 数据源没有加载事务管理器 发生自调用的情况 事务注解的本质原理是什么 事务注解仅仅代表事务相关的元数据，在运行时被事务基础设施读取并消费，根据这些元数据来配置事务的行为。事务注解主要依赖于Spring AOP，使用了一个事务拦截器，在方法调用前后进行事务增强。 Spring 框架中用到了哪些设计模式？ 工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 原型模式：Spring Bean 如果配置了prototype模式的话，那么每次都会通过克隆的方式生成新对象。 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 观察者模式: Spring 中的 Event 和 Listener。 spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。 spring 事件监听器：ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。 BeanPostProcessor与BeanFactoryPostProcessor的区别 说说Spring 中 ApplicationContext 和 BeanFactory 的区别 BeanFactory是最原始的接口，提供了最基本的容器功能 ApplicationContext实现了BeanFactory 接口，对容器的功能做了进一步的扩展，比如 支持了国际化 支持事件发布与监听 支持读取环境变量 ApplicationContext的初始化和BeanFactory有一个重大的区别:BeanFactory在初始化容器时，并未实例化Bean,直到第一次访问某个Bean时才实例目标Bean;而ApplicationContext则在初始化应用上下文时就实例化所有的单实例的Bean。因此ApplicationContext的初始化时间会比BeanFactory稍长一些。 SpringIOC的启动流程 IOC 是什么 IOC是控制反转，把对象的控制权转移到ioc容器。应用程序如果需要使用到某个对象实例，直接从 IOC 容器中去获取就行，这样设计的好处是降低了程序里面对象与对象之间的耦合性。 Bean的声明方式 spring声明bean的方式有很多种，可以在xml配置，@Bean注解，@Component，@Service，@Repository等等。 Spring 在启动的时候会去扫描解析这些bean，然后保存到ioc容器中 ioc的工作流程大致分为两个阶段 ioc的初始化 通过xml配置或者注解配置信息解析生成BeanDefiniton，注册到BeanDefinitonMap 遍历这个map，走bean的生命周期 ioc容器的使用方式 通过@Autowired自动注入 通过BeanFactory.getBean() 获取IOC容器的bean 另外，需要注意的是，对于那些指定lazy-init的bean，ioc容器启动的时候不会去实例化它，而是在第一次获取的时候去实例化它，而且ioc容器不会去管理这些bean Spring常用的注解 创建Bean的注解 @Configuration 配合@Bean @Component @Controller @Service @Repository 注入属性 @Autowired @Qualifier @Resource @Value 作用域注解 @Scope 配置类相关 @ComponentScan @Import @PropertySource 指定Properties文件的位置","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/bluesky-java-interview/java/Spring.html"}],["meta",{"property":"og:site_name","content":"BlueSky的八股文"}],["meta",{"property":"og:title","content":"Spring"}],["meta",{"property":"og:description","content":"Spring IOC/AOP Spring的理解（IOC和AOP） 首先，spring是个庞大的项目，从官网可以看到包括了： SpringFramework SpringData SpringSecurity SpringBoot SpringCloud 当然，除了这些之外，Spring还包括很多其他的项目 Spring最主要的有两个特点是IOC和AOP IOC: IOC就是控制反转，指的是创建对象控制权的转移，以前创建对象的时候都是自己控制，现在Spring容器会根据配置文件去帮我们创建和管理对象。 好处：解耦合，对象的属性只需要在配置文件中写，不用在java代码写，把属性与java代码解耦合。 原理：使用反射机制，根据配置文件信息去创建对象。使用了工厂的设计模式。 Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。 AOP: 把公共的代码提取出来，进行封装。 减少系统代码重复量，降低模块耦合度。 原理：基于动态代理 要代理的对象实现了接口，就用JDK动态代理生成代理类。 没有实现接口，就用cglib，实现子类的方式生成代理类。 孙帅的IOC和DI IOC 控制反转 控制：对于成员变量赋值的控制权 控制反转：把成员变量赋值的控制权，从代码中反转到Spring工厂和配置文件中完成。 好处：解耦合 底层实现：反射加工厂设计模式 DI 依赖注入 当一个类需要另一个类时，就意味着依赖，一旦出现了依赖，那么就可以把另一个类作为本类的成员变量，最终通过Spring配置文件注入。 类加载器的作用 通过类加载器把对应class文件加载到JVM 通过类加载器创建类的Class对象，进而创建这个类的对象 User —&gt; user User类的Class对象 —&gt;new User() —&gt;user 如何获取类加载器：每一个.class文件，JVM会自动分配与之对应的ClassLoader 代理创建3要素（孙帅） 原始对象 额外功能 代理对象和原始对象实现相同的接口 JDK动态代理 （孙帅） Proxy.newProxyInstance(classloader,interfacce,invocationhandler) 为什么JDK动态代理中，该api需要我们传入classloader？ 创建代理类的对象需要用到类加载器 JDK动态代理没有相应的class文件，那么JVM就不会为其分配ClassLoader，所以需要我们为其指定classLoader（借用类加载器）。 Spring AOP和AspectJ 有什么区别？ AOP是运行时增强，AspectJ是编译时增强。 AOP是动态代理方式实现，AspectJ是基于ASM修改字节码。 AspectJ性能比较好，切面多的话，用AspectJ Spring切面的五种通知类型 before，前置通知，在方法调用前执行 after 方法执行后调用 around 之前之后都执行 after-returning 方法成功执行完成后执行 after-throwing 方法执行报错后执行 Autowired和Resource关键字的区别？ 共同点： 写在字段或者Setter方法上 都用于bean的注入 不同点： Autowired是Spring 提供的注解，而@Resource是javax包的注解 Autowired 是ByType来装配对象，如果想ByName可以通过配合@Qualifer使用，而@Resource默认是根据ByName来装配，如果想改为ByType，使用type属性 Spring bean 的生命周期 实例化bean：推断构造方法，实例化bean 设置对象属性（依赖注入）：实例化后的baen被封装到beanWrapper中，完成依赖注入 处理Aware接口： 如果Bean实现了BeanNameAware接口，会调用setBeanName()方法 如果实现了BeanFactoryAware接口，调用setBeanFactory()方法 BeanPostProcessor 如果bean实现了BeanPostProcessor接口，那么会调用postprocessBeforeInitialization() 初始化 如果Bean中的某个方法被@PostConstruct 标记，那么就去调用它 如果实现了InitializingBean，调用afterPropertiesSet方法 如果Bean 指定了init-method 方法，那么就去调用它。 如果Bean实现了BeanPostProcessor接口，会调用postProcessAfterInitialization() bean不再需要的时候，会被销毁，如果实现了disposableBean接口，那么就调用destory方法。 bean的作用域 singleton：默认，容器只有一个bean prototype：每个请求创建一个bean request：每个网络请求创建一个bean session：每个session创建一个bean global-session：global-session跟Portlet应用相关的 Spring中单例bean是线程安全的吗 关于单例bean的线程安全问题需要由开发者自己去控制，Spring并没有做线程安全方面的控制 Spring 基于xml注入的方式有哪些 Set方法注入 构造器注入 Spring如何解决循环依赖问题（简单版本） 对于普通Java对象，对象之间的依赖问题很好解决，比如X依赖Y，Y依赖X。 X x= new X(); x.setY (); Y y=new Y();y.setX() 由于Spring bean 有着复杂的生命周期，所以解决循环依赖问题也稍微麻烦一点，主要影响的是 实例化 填充属性 初始化 Spring 使用了三级缓存来解决循环依赖的问题 singletonObjects 用于存放可以直接使用的单例bean earlySingletonObjects 用于存放没填充属性的bean singletonFactories 存放bean工厂 对于对象A依赖B，对象B依赖A的情况 在对象A实例化后，会提前暴露到earlySingletonObjects 接着填充属性，发现此时依赖了B，发现没有B，走B的创建过程 B实例化后，填充属性，发现依赖了A，从earlySingletonObjects 中获取到了未填充属性的A，设置A，完成初始化后把自己放到singletonObjects里 返回A继续填充B，发现B已经在singletonObjects里面了，直接填充B 解决了循环依赖问题 前面有提到三级缓存，三级缓存的作用是什么？ 三级缓存是用来存储代理 Bean，当调用 getBean()方法时，发现目标 Bean 需要通过代理工厂来创建，此时会将创建好的实例保存到三级缓存，最终也会将赋值好的 Bean 同步到一级缓存中。 Spring 中哪些情况下，不能解决循环依赖问题？ 多例 Bean 通过 setter 注入的情况，不能解决循环依赖问题 构造器注入的 Bean 的情况，不能解决循环依赖问题 单例的代理 Bean 通过 Setter 注入的情况，不能解决循环依赖问题 设置了@DependsOn 的 Bean 的情况，不能解决循环依赖问 Spring的循环依赖（子路老师https://www.bilibili.com/video/BV1Ga4y1E7Br） 对于普通的Java对象的循环依赖问题，他们之间是很好解决的，比如X依赖Y，Y依赖X，这种是很好解决的： X x= new X(); x.setY (); Y y=new Y();y.setX() Spring的循环依赖之所以复杂，是因为Spring Bean有着不同于普通Java对象的复杂生命周期，所以要讲一下Spring Bean的生命周期 首先Spring 容器启动后，他会去做一个扫描，扫描之后把他变成BeanDefinition存到一个BeanDefinitionMap中 然后对这个Map去遍历，并做验证，比如验证是否单例，是否懒加载，是否有depend on，是否抽象等等。 然后获取当前实例化的类有没有存在单例池中，有没有被提前暴露。如果没有被提前暴露的话，Spring Bean就会被开始创建。 通过推断构造方法，推断出一个最佳的构造方法，然后通过反射去实例化Java对象 判断是否做BeanDefinition的合并，Spring容器是否支持循环依赖，如果支持循环依赖的话，会提前暴露一个半成品的Bean到ObjectFactory，存到一个二级缓存Map中。 做一些属性填充 做一些Aware接口的回调，比如BeanNameAware，ApplicationContextAware，ClassLoaderAware等等。 如果实现了PostProcessor接口的话，就做初始化之前的方法回调。 然后做一些初始化的回调，@PostConstruct，InitializingBean，或者init-method方法。 如果实现了PostProcessor接口的话，就做初始化之后的方法回调。 这样的话，整个Spring Bean基本可以满足使用了。把这个Bean放入到单例池。 Spring的循环依赖解决大概： 实例化X的时候，首先对X做一些基本的验证，验证完之后，看一下X所对应的ObjectFactory有没有提前暴露，这种时候肯定是没有的 ，接着就推断构造方法。接着就把X实例化出来，X实例化出来就会提前暴露。接着就是X的属性填充，发现了需要填充Y。 发现Y并没有被实例化，走Y的生命周期过程，发现Y也没有提前暴露，继续走实例化Y，实例化Y后继续往下执行，把Y提前暴露。接着做Y的属性填充，发现需要填充X，但是X并没有在单例池中（X实例化只是走了一半）。 继续走X的生命周期流程，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;解决循环依赖。 Spring 实例化Bean推断构造方法 如果@Autowired指定了构造方法，那么就使用该构造方法 如果没有指定 优先使用无参构造 如果没有无参构造方法，有两个及以上的构造方法，会报错 Spring事务实现方式 编程事务 声明式事务@Transcation Spring事务的传播级别（7个） PROPAGATION_REQUIRED：默认的Spring事务传播级别，若当前存在事务就加入事务，没有就创建一个 PAOPAGATION_REQUIRE_NEW：不管有没有事务都新建一个，新老事务相互独立 PROPAGATION_SUPPORTS：当前存在事务，就加入其中，没有事务就不走事务 PROPAGATION_NOT_SUPPORTED：以非事务的方式运行，存在事务就先把事务挂起 PROPAGATION_MANDATORY：强制事务执行，若当前不存在，则抛出异常 PROPAGATION_NEVER: 以非事务的方式执行，如果当前存在事务，则抛出异常 PROPAGATION_NESTED：存在事务，嵌套其中，没有事务，创建一个 Spring 事务失效的原因 数据库存储引擎不支持事务 异常被捕获，没有抛出异常 异常类型错误，默认是RuntimeExcetion 注解所在的方法不是public 事务类没有被spring容器管理 事务属性配置不正确，propagation属性配置为不适用事务 数据源没有加载事务管理器 发生自调用的情况 事务注解的本质原理是什么 事务注解仅仅代表事务相关的元数据，在运行时被事务基础设施读取并消费，根据这些元数据来配置事务的行为。事务注解主要依赖于Spring AOP，使用了一个事务拦截器，在方法调用前后进行事务增强。 Spring 框架中用到了哪些设计模式？ 工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 原型模式：Spring Bean 如果配置了prototype模式的话，那么每次都会通过克隆的方式生成新对象。 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 观察者模式: Spring 中的 Event 和 Listener。 spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。 spring 事件监听器：ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。 BeanPostProcessor与BeanFactoryPostProcessor的区别 说说Spring 中 ApplicationContext 和 BeanFactory 的区别 BeanFactory是最原始的接口，提供了最基本的容器功能 ApplicationContext实现了BeanFactory 接口，对容器的功能做了进一步的扩展，比如 支持了国际化 支持事件发布与监听 支持读取环境变量 ApplicationContext的初始化和BeanFactory有一个重大的区别:BeanFactory在初始化容器时，并未实例化Bean,直到第一次访问某个Bean时才实例目标Bean;而ApplicationContext则在初始化应用上下文时就实例化所有的单实例的Bean。因此ApplicationContext的初始化时间会比BeanFactory稍长一些。 SpringIOC的启动流程 IOC 是什么 IOC是控制反转，把对象的控制权转移到ioc容器。应用程序如果需要使用到某个对象实例，直接从 IOC 容器中去获取就行，这样设计的好处是降低了程序里面对象与对象之间的耦合性。 Bean的声明方式 spring声明bean的方式有很多种，可以在xml配置，@Bean注解，@Component，@Service，@Repository等等。 Spring 在启动的时候会去扫描解析这些bean，然后保存到ioc容器中 ioc的工作流程大致分为两个阶段 ioc的初始化 通过xml配置或者注解配置信息解析生成BeanDefiniton，注册到BeanDefinitonMap 遍历这个map，走bean的生命周期 ioc容器的使用方式 通过@Autowired自动注入 通过BeanFactory.getBean() 获取IOC容器的bean 另外，需要注意的是，对于那些指定lazy-init的bean，ioc容器启动的时候不会去实例化它，而是在第一次获取的时候去实例化它，而且ioc容器不会去管理这些bean Spring常用的注解 创建Bean的注解 @Configuration 配合@Bean @Component @Controller @Service @Repository 注入属性 @Autowired @Qualifier @Resource @Value 作用域注解 @Scope 配置类相关 @ComponentScan @Import @PropertySource 指定Properties文件的位置"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"blueSky"}],["meta",{"property":"article:tag","content":"spring"}],["meta",{"property":"article:tag","content":"springboot"}],["meta",{"property":"article:published_time","content":"2023-08-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"blueSky\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"IOC/AOP","slug":"ioc-aop","link":"#ioc-aop","children":[]},{"level":2,"title":"MVC","slug":"mvc","link":"#mvc","children":[]},{"level":2,"title":"SpringBoot","slug":"springboot","link":"#springboot","children":[]}],"git":{},"readingTime":{"minutes":15.23,"words":4568},"filePathRelative":"java/Spring.md","localizedDate":"August 8, 2023","excerpt":"<h1> Spring</h1>\\n<h2> IOC/AOP</h2>\\n<ul>\\n<li>\\n<p>Spring的理解（IOC和AOP）</p>\\n<ul>\\n<li>\\n<p>首先，spring是个庞大的项目，从官网可以看到包括了：</p>\\n<ul>\\n<li>SpringFramework</li>\\n<li>SpringData</li>\\n<li>SpringSecurity</li>\\n<li>SpringBoot</li>\\n<li>SpringCloud</li>\\n</ul>\\n<p>当然，除了这些之外，Spring还包括很多其他的项目</p>\\n</li>\\n</ul>\\n<p>Spring最主要的有两个特点是IOC和AOP</p>\\n<ul>\\n<li>IOC:\\n<ul>\\n<li>IOC就是控制反转，指的是创建对象控制权的转移，以前创建对象的时候都是自己控制，现在Spring容器会根据配置文件去帮我们创建和管理对象。</li>\\n<li>好处：解耦合，对象的属性只需要在配置文件中写，不用在java代码写，把属性与java代码解耦合。</li>\\n<li>原理：使用反射机制，根据配置文件信息去创建对象。使用了工厂的设计模式。</li>\\n<li>Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</li>\\n</ul>\\n</li>\\n<li>AOP:\\n<ul>\\n<li>把公共的代码提取出来，进行封装。</li>\\n<li>减少系统代码重复量，降低模块耦合度。</li>\\n<li>原理：基于动态代理\\n<ul>\\n<li>要代理的对象实现了接口，就用JDK动态代理生成代理类。</li>\\n<li>没有实现接口，就用cglib，实现子类的方式生成代理类。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>孙帅的IOC和DI</p>\\n<ul>\\n<li>IOC 控制反转\\n<ul>\\n<li>控制：对于成员变量赋值的控制权</li>\\n<li>控制反转：把成员变量赋值的控制权，从代码中反转到Spring工厂和配置文件中完成。</li>\\n<li>好处：解耦合</li>\\n<li>底层实现：反射加工厂设计模式</li>\\n</ul>\\n</li>\\n<li>DI  依赖注入\\n<ul>\\n<li>当一个类需要另一个类时，就意味着依赖，一旦出现了依赖，那么就可以把另一个类作为本类的成员变量，最终通过Spring配置文件注入。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>类加载器的作用</p>\\n<ul>\\n<li>通过类加载器把对应class文件加载到JVM</li>\\n<li>通过类加载器创建类的Class对象，进而创建这个类的对象\\n<ul>\\n<li>User —&gt; user\\n<ul>\\n<li>User类的Class对象 —&gt;new User() —&gt;user</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>如何获取类加载器：每一个.class文件，JVM会自动分配与之对应的ClassLoader</li>\\n</ul>\\n</li>\\n<li>\\n<p>代理创建3要素（孙帅）</p>\\n<ul>\\n<li>原始对象</li>\\n<li>额外功能</li>\\n<li>代理对象和原始对象实现相同的接口</li>\\n</ul>\\n</li>\\n<li>\\n<p>JDK动态代理 （孙帅）</p>\\n<ul>\\n<li>Proxy.newProxyInstance(classloader,interfacce,invocationhandler)</li>\\n<li>为什么JDK动态代理中，该api需要我们传入classloader？\\n<ul>\\n<li>创建代理类的对象需要用到类加载器</li>\\n<li>JDK动态代理没有相应的class文件，那么JVM就不会为其分配ClassLoader，所以需要我们为其指定classLoader（借用类加载器）。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring AOP和AspectJ 有什么区别？</p>\\n<ul>\\n<li>AOP是运行时增强，AspectJ是编译时增强。</li>\\n<li>AOP是动态代理方式实现，AspectJ是基于ASM修改字节码。</li>\\n<li>AspectJ性能比较好，切面多的话，用AspectJ</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring切面的五种通知类型</p>\\n<ul>\\n<li>before，前置通知，在方法调用前执行</li>\\n<li>after 方法执行后调用</li>\\n<li>around 之前之后都执行</li>\\n<li>after-returning 方法成功执行完成后执行</li>\\n<li>after-throwing 方法执行报错后执行</li>\\n</ul>\\n</li>\\n<li>\\n<p>Autowired和Resource关键字的区别？</p>\\n<ul>\\n<li>共同点：\\n<ul>\\n<li>写在字段或者Setter方法上</li>\\n<li>都用于bean的注入</li>\\n</ul>\\n</li>\\n<li>不同点：\\n<ul>\\n<li>Autowired是Spring 提供的注解，而@Resource是javax包的注解</li>\\n<li>Autowired 是ByType来装配对象，如果想ByName可以通过配合@Qualifer使用，而@Resource默认是根据ByName来装配，如果想改为ByType，使用type属性</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring bean 的生命周期</p>\\n<ul>\\n<li>实例化bean：推断构造方法，实例化bean</li>\\n<li>设置对象属性（依赖注入）：实例化后的baen被封装到beanWrapper中，完成依赖注入</li>\\n<li>处理Aware接口：\\n<ul>\\n<li>如果Bean实现了BeanNameAware接口，会调用setBeanName()方法</li>\\n<li>如果实现了BeanFactoryAware接口，调用setBeanFactory()方法</li>\\n</ul>\\n</li>\\n<li>BeanPostProcessor\\n<ul>\\n<li>如果bean实现了BeanPostProcessor接口，那么会调用postprocessBeforeInitialization()</li>\\n</ul>\\n</li>\\n<li>初始化\\n<ul>\\n<li>如果Bean中的某个方法被@PostConstruct 标记，那么就去调用它</li>\\n<li>如果实现了InitializingBean，调用afterPropertiesSet方法</li>\\n<li>如果Bean 指定了init-method 方法，那么就去调用它。</li>\\n</ul>\\n</li>\\n<li>如果Bean实现了BeanPostProcessor接口，会调用postProcessAfterInitialization()</li>\\n<li>bean不再需要的时候，会被销毁，如果实现了disposableBean接口，那么就调用destory方法。</li>\\n</ul>\\n</li>\\n<li>\\n<p>bean的作用域</p>\\n<ul>\\n<li>singleton：默认，容器只有一个bean</li>\\n<li>prototype：每个请求创建一个bean</li>\\n<li>request：每个网络请求创建一个bean</li>\\n<li>session：每个session创建一个bean</li>\\n<li>global-session：global-session跟Portlet应用相关的</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring中单例bean是线程安全的吗</p>\\n<ul>\\n<li>关于单例bean的线程安全问题需要由开发者自己去控制，Spring并没有做线程安全方面的控制</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring 基于xml注入的方式有哪些</p>\\n<ul>\\n<li>Set方法注入</li>\\n<li>构造器注入</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring如何解决循环依赖问题（简单版本）</p>\\n<ul>\\n<li>对于普通Java对象，对象之间的依赖问题很好解决，比如X依赖Y，Y依赖X。\\n<ul>\\n<li>X x= new X(); x.setY ();</li>\\n<li>Y y=new Y();y.setX()</li>\\n</ul>\\n</li>\\n<li>由于Spring bean 有着复杂的生命周期，所以解决循环依赖问题也稍微麻烦一点，主要影响的是\\n<ul>\\n<li>实例化</li>\\n<li>填充属性</li>\\n<li>初始化</li>\\n</ul>\\n</li>\\n<li>Spring 使用了三级缓存来解决循环依赖的问题\\n<ul>\\n<li>singletonObjects 用于存放可以直接使用的单例bean</li>\\n<li>earlySingletonObjects 用于存放没填充属性的bean</li>\\n<li>singletonFactories 存放bean工厂</li>\\n</ul>\\n</li>\\n<li>对于对象A依赖B，对象B依赖A的情况\\n<ul>\\n<li>在对象A实例化后，会提前暴露到earlySingletonObjects</li>\\n<li>接着填充属性，发现此时依赖了B，发现没有B，走B的创建过程</li>\\n<li>B实例化后，填充属性，发现依赖了A，从earlySingletonObjects 中获取到了未填充属性的A，设置A，完成初始化后把自己放到singletonObjects里</li>\\n<li>返回A继续填充B，发现B已经在singletonObjects里面了，直接填充B</li>\\n<li>解决了循环依赖问题</li>\\n</ul>\\n</li>\\n<li>前面有提到三级缓存，三级缓存的作用是什么？\\n<ul>\\n<li>三级缓存是用来存储代理 Bean，当调用 getBean()方法时，发现目标 Bean 需要通过代理工厂来创建，此时会将创建好的实例保存到三级缓存，最终也会将赋值好的 Bean 同步到一级缓存中。</li>\\n</ul>\\n</li>\\n<li>Spring 中哪些情况下，不能解决循环依赖问题？\\n<ul>\\n<li>多例 Bean 通过 setter 注入的情况，不能解决循环依赖问题</li>\\n<li>构造器注入的 Bean 的情况，不能解决循环依赖问题</li>\\n<li>单例的代理 Bean 通过 Setter 注入的情况，不能解决循环依赖问题</li>\\n<li>设置了@DependsOn 的 Bean 的情况，不能解决循环依赖问</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring的循环依赖（子路老师<a href=\\"https://www.bilibili.com/video/BV1Ga4y1E7Br\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://www.bilibili.com/video/BV1Ga4y1E7Br</a>）</p>\\n<ul>\\n<li>对于普通的Java对象的循环依赖问题，他们之间是很好解决的，比如X依赖Y，Y依赖X，这种是很好解决的：\\n<ul>\\n<li>X x= new X(); x.setY ();</li>\\n<li>Y y=new Y();y.setX()</li>\\n</ul>\\n</li>\\n<li>Spring的循环依赖之所以复杂，是因为Spring Bean有着不同于普通Java对象的复杂生命周期，所以要讲一下Spring Bean的生命周期\\n<ul>\\n<li>首先Spring 容器启动后，他会去做一个扫描，扫描之后把他变成BeanDefinition存到一个BeanDefinitionMap中</li>\\n<li>然后对这个Map去遍历，并做验证，比如验证是否单例，是否懒加载，是否有depend on，是否抽象等等。</li>\\n<li>然后获取当前实例化的类有没有存在单例池中，有没有被提前暴露。如果没有被提前暴露的话，Spring Bean就会被开始创建。</li>\\n<li>通过推断构造方法，推断出一个最佳的构造方法，然后通过反射去实例化Java对象</li>\\n<li>判断是否做BeanDefinition的合并，Spring容器是否支持循环依赖，如果支持循环依赖的话，会提前暴露一个半成品的Bean到ObjectFactory，存到一个二级缓存Map中。</li>\\n<li>做一些属性填充</li>\\n<li>做一些Aware接口的回调，比如BeanNameAware，ApplicationContextAware，ClassLoaderAware等等。</li>\\n<li>如果实现了PostProcessor接口的话，就做初始化之前的方法回调。</li>\\n<li>然后做一些初始化的回调，@PostConstruct，InitializingBean，或者init-method方法。</li>\\n<li>如果实现了PostProcessor接口的话，就做初始化之后的方法回调。</li>\\n<li>这样的话，整个Spring Bean基本可以满足使用了。把这个Bean放入到单例池。</li>\\n</ul>\\n</li>\\n<li>Spring的循环依赖解决大概：\\n<ul>\\n<li>实例化X的时候，首先对X做一些基本的验证，验证完之后，看一下X所对应的ObjectFactory有没有提前暴露，这种时候肯定是没有的 ，接着就推断构造方法。接着就把X实例化出来，X实例化出来就会提前暴露。接着就是X的属性填充，发现了需要填充Y。</li>\\n<li>发现Y并没有被实例化，走Y的生命周期过程，发现Y也没有提前暴露，继续走实例化Y，实例化Y后继续往下执行，把Y提前暴露。接着做Y的属性填充，发现需要填充X，但是X并没有在单例池中（X实例化只是走了一半）。</li>\\n<li>继续走X的生命周期流程，当走到去二级缓存中找的时候找到了-&gt;往Y中注入X的objectFactory对象-&gt;解决循环依赖。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring 实例化Bean推断构造方法</p>\\n<ul>\\n<li>如果@Autowired指定了构造方法，那么就使用该构造方法</li>\\n<li>如果没有指定\\n<ul>\\n<li>优先使用无参构造</li>\\n<li>如果没有无参构造方法，有两个及以上的构造方法，会报错</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring事务实现方式</p>\\n<ul>\\n<li>编程事务</li>\\n<li>声明式事务@Transcation</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring事务的传播级别（7个）</p>\\n<ul>\\n<li>PROPAGATION_REQUIRED：默认的Spring事务传播级别，若当前存在事务就加入事务，没有就创建一个</li>\\n<li>PAOPAGATION_REQUIRE_NEW：不管有没有事务都新建一个，新老事务相互独立</li>\\n<li>PROPAGATION_SUPPORTS：当前存在事务，就加入其中，没有事务就不走事务</li>\\n<li>PROPAGATION_NOT_SUPPORTED：以非事务的方式运行，存在事务就先把事务挂起</li>\\n<li>PROPAGATION_MANDATORY：强制事务执行，若当前不存在，则抛出异常</li>\\n<li>PROPAGATION_NEVER: 以非事务的方式执行，如果当前存在事务，则抛出异常</li>\\n<li>PROPAGATION_NESTED：存在事务，嵌套其中，没有事务，创建一个</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring 事务失效的原因</p>\\n<ul>\\n<li>数据库存储引擎不支持事务</li>\\n<li>异常被捕获，没有抛出异常</li>\\n<li>异常类型错误，默认是RuntimeExcetion</li>\\n<li>注解所在的方法不是public</li>\\n<li>事务类没有被spring容器管理</li>\\n<li>事务属性配置不正确，propagation属性配置为不适用事务</li>\\n<li>数据源没有加载事务管理器</li>\\n<li>发生自调用的情况</li>\\n</ul>\\n</li>\\n<li>\\n<p>事务注解的本质原理是什么</p>\\n<ul>\\n<li>事务注解仅仅代表事务相关的元数据，在运行时被事务基础设施读取并消费，根据这些元数据来配置事务的行为。事务注解主要依赖于Spring AOP，使用了一个事务拦截器，在方法调用前后进行事务增强。</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring 框架中用到了哪些设计模式？</p>\\n<ul>\\n<li>工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>\\n<li>代理设计模式 : Spring AOP 功能的实现。</li>\\n<li>单例设计模式 : Spring 中的 Bean 默认都是单例的。</li>\\n<li>原型模式：Spring Bean 如果配置了prototype模式的话，那么每次都会通过克隆的方式生成新对象。</li>\\n<li>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>\\n<li>观察者模式: Spring 中的 Event 和 Listener。\\n<ul>\\n<li>spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。\\n<ul>\\n<li>spring 事件监听器：ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<h2> BeanPostProcessor与BeanFactoryPostProcessor的区别</h2>\\n</li>\\n<li>\\n<p>说说Spring 中 ApplicationContext 和 BeanFactory 的区别</p>\\n<ul>\\n<li>BeanFactory是最原始的接口，提供了最基本的容器功能</li>\\n<li>ApplicationContext实现了BeanFactory 接口，对容器的功能做了进一步的扩展，比如\\n<ul>\\n<li>支持了国际化</li>\\n<li>支持事件发布与监听</li>\\n<li>支持读取环境变量</li>\\n</ul>\\n</li>\\n<li>ApplicationContext的初始化和BeanFactory有一个重大的区别:BeanFactory在初始化容器时，并未实例化Bean,直到第一次访问某个Bean时才实例目标Bean;而ApplicationContext则在初始化应用上下文时就实例化所有的单实例的Bean。因此ApplicationContext的初始化时间会比BeanFactory稍长一些。</li>\\n</ul>\\n</li>\\n<li>\\n<p>SpringIOC的启动流程</p>\\n<ul>\\n<li>IOC 是什么\\n<ul>\\n<li>IOC是控制反转，把对象的控制权转移到ioc容器。应用程序如果需要使用到某个对象实例，直接从 IOC 容器中去获取就行，这样设计的好处是降低了程序里面对象与对象之间的耦合性。</li>\\n</ul>\\n</li>\\n<li>Bean的声明方式\\n<ul>\\n<li>spring声明bean的方式有很多种，可以在xml配置，@Bean注解，@Component，@Service，@Repository等等。</li>\\n<li>Spring 在启动的时候会去扫描解析这些bean，然后保存到ioc容器中</li>\\n</ul>\\n</li>\\n<li>ioc的工作流程大致分为两个阶段\\n<ul>\\n<li>ioc的初始化\\n<ul>\\n<li>通过xml配置或者注解配置信息解析生成BeanDefiniton，注册到BeanDefinitonMap</li>\\n<li>遍历这个map，走bean的生命周期</li>\\n</ul>\\n</li>\\n<li>ioc容器的使用方式\\n<ul>\\n<li>通过@Autowired自动注入</li>\\n<li>通过BeanFactory.getBean() 获取IOC容器的bean</li>\\n</ul>\\n</li>\\n<li>另外，需要注意的是，对于那些指定lazy-init的bean，ioc容器启动的时候不会去实例化它，而是在第一次获取的时候去实例化它，而且ioc容器不会去管理这些bean</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>Spring常用的注解</p>\\n<ul>\\n<li>创建Bean的注解\\n<ul>\\n<li>@Configuration 配合@Bean</li>\\n<li>@Component</li>\\n<li>@Controller</li>\\n<li>@Service</li>\\n<li>@Repository</li>\\n</ul>\\n</li>\\n<li>注入属性\\n<ul>\\n<li>@Autowired</li>\\n<li>@Qualifier</li>\\n<li>@Resource</li>\\n<li>@Value</li>\\n</ul>\\n</li>\\n<li>作用域注解\\n<ul>\\n<li>@Scope</li>\\n</ul>\\n</li>\\n<li>配置类相关\\n<ul>\\n<li>@ComponentScan</li>\\n<li>@Import</li>\\n<li>@PropertySource 指定Properties文件的位置</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{n as data};
