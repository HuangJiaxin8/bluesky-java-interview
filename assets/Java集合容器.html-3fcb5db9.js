import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,f as e}from"./app-c550aa6e.js";const t={},r=e('<h1 id="java集合容器" tabindex="-1"><a class="header-anchor" href="#java集合容器" aria-hidden="true">#</a> Java集合容器</h1><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h2><ul><li>集合继承关系： <ul><li>Collection <ul><li>List</li><li>Queue</li><li>Set</li></ul></li><li>Map</li></ul></li></ul><figure><img src="https://secure2.wostatic.cn/static/gsNa2EjQw4vUmnRSzEd449/image.png?auth_key=1691508915-d7XzbKoCqWo2iJJ27aKoRY-0-db39d4ca9cd5fe83c49bd921ff1b0db7" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>List：有序可重复</p></li><li><p>Set：无序不重复</p></li><li><p>Queue：先进先出，有序可重复</p></li><li><p>Map：key-value 映射，key无序不重复，value无序可重复</p></li><li><p>List 和 Array如何想换转换</p><ul><li>List接口里有个toArray方法 可以把List转换为Array</li><li>Arrays.asList() 可以把数组转化为List</li></ul></li><li><p>ArrayList</p><ul><li><p>ArrayList扩容为什么是1.5倍</p><ul><li>首先，为了充分利用空间，最好是1-2之间</li><li>为什么不是1.25和1.75,为啥选择1.5呢 <ul><li>为了使用位运算，提高性能:newCapacity = oldCapacity +( oldCapacity&gt;&gt;1)</li></ul></li></ul></li></ul></li><li><p>ArrayList 有100个元素，如何删除20-50的元素</p><ul><li>list.subList(20,51).clear();</li><li>因为是左闭右开，所以50要+1</li></ul></li><li><p>ArrayList与LinkedList的区别</p><ul><li>区别的话，我们要站在底层的数据结构的角度来进行分析的。</li><li>ArrayList底层是基于数组来实现的，数组容量满的时候是需要扩容的。</li><li>而LinkedList底层是基于链表来实现的，而链表是不需要扩容的。他在存放数据的时候只需要.next,.next,把我们的数据存放到尾结点。所以，LinkedList是没有容量限制的，只要我们的服务器内存足够的话，它是可以无限存放的。相对于ArrayList，它在做新增的时候它的效率是高非常多的。</li></ul></li><li><p>ArrayList与LinkedList查询时候有什么区别</p><ul><li>查询的时候，也是要站在底层的数据结构角度来进行分析的。</li><li>ArrayList底层是基于数组来实现的，数据可以根据索引下标Index来查询的，时间复杂度是O(1)。</li><li>而LinkedList查询的时间复杂度是O(n),它需要从头查询到尾部，它的查询效率是非常低的。</li><li>反过来，如果ArrayList不是根据index下标来查询的话，那么查询效率也是比较低，是需要一直从头查询到尾部的。所以在中间就要整合到一些折半算法。</li></ul></li><li><p>ArrayList的扩容机制</p><ul><li>ArrayList 是一个数组的数据结构，默认情况下，数组的长度是 10。</li><li>当底层数组容量不够时，会自动发生扩容，扩容后大小是原来的1.5倍。</li><li>扩容的具体流程很简单： <ul><li>首先，创建一个新的数组，这个新数组的长度是原来数组长度的 1.5 倍。</li><li>然后使用 Arrays.copyOf 方法把老数组里面的数据拷贝到新的数组里面。</li><li>扩容完成后再把当前要添加的元素加入到新的数组里面，从而完成动态扩容的过程。</li></ul></li></ul></li><li><p>HashMap存放数据是有序还是无序的</p><ul><li>是无序的，为什么HashMap是无序的呢</li><li>是因为我们HashMap集合，他在存放数据时候，会根据我们的key来计算index值，而这个index值它是散列的，是无序的。</li><li>如果想要实现有序的map的话，可以使用LinkedHashMap，底层是通过双链表，连接每一个key，保证我们在遍历时候是有定顺序的。</li></ul></li><li><p>HashMap的底层原理</p><ul><li>数据结构 <ul><li>在JDK1.7中，使用的是数组+链表的数据结构。</li><li>在JDK1.8的时候，使用的是数组+链表，链表到达一定条件转化为红黑树的数据结构。</li></ul></li><li>put值的过程 <ul><li>首先根据key的hashCode参数去做hash算法得到hash值，然后通过算法（n-1）&amp; hash 得到该元素存放的数组位置，如果数组位置上没值直接插入，如果有值通过比较key是否相同，如果相同就直接覆盖，不相同则通过拉链法解决冲突。</li></ul></li><li>数组初始容量为16，扩容因子为0.75，每次采用2倍扩容。 <ul><li>啊里巴巴规范中，提到HashMap构造的时候就要传入数组的大小，而且最好是n次幂。</li><li>数组大小一般传入2的n次幂，如果传入的不是2的n次幂，内部会自动转化为2的n次幂。</li><li>2的n次幂的目的是： <ul><li>底层有个算法(n-1)&amp;hash用来计算元素具体在哪个位置，如果n是2次幂，（n-1）的二进制就是，11...111 ,比较方便位计算，同时能够更散列，减少hash冲突。</li></ul></li><li>为什么采用2倍扩容： <ul><li>为了方便位运算</li></ul></li></ul></li><li>JDK1.7采用头插法，JDK1.8采用尾插法。目的：解决循环链表。 <ul><li>死循环是发生在并发环境下，并且发生数组扩容</li><li>比如链表ABC，因为是头插法，然后扩容后的链表是CBA</li><li>而扩容前，有两个线程T1，T2，都指向了A,而next都指向了B，而扩容发生在线程T1中，那么线程T2是不知道的，那么线程B中的链表会变成CBAB这样的循环链表</li></ul></li><li>树化条件是：链表长度大于8，并且数组长度大于64。</li><li>链化条件:链表长度等于6 <ul><li>为啥要设计为6，不设计为7，是为了不频繁的进行链化和树化。</li><li>如果设计为7，那么删除一个元素，就要链化，再增加一个元素，等于8，又要树化。反复的树化和链化都很浪费性能。</li></ul></li></ul></li><li><p>HashMap与HashTable的区别</p><ul><li>父类不同 <ul><li>HashMap是继承自AbstractMap类，而Hashtable是继承自 Dictionary类</li></ul></li><li>对null支持不同 <ul><li>Hashtable： key和value都不能为null。</li><li>HashMap： key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。</li></ul></li><li>线程安全不同 <ul><li>HashMap线程不安全</li><li>HashTable线程安全</li></ul></li></ul></li><li><p>ConcurrentHashMap的底层原理</p><ul><li>在JDK7 中 <ul><li>ConcurrentHashMap是通过分段锁来设计的，把一个大的HashTable集合，拆分成n多个小的hashtable集合（segment），这样的话，它的锁粒度就比较小。</li><li>不像HashTable集合，把整个table数组都锁住了，所以HashTable效率比较低。</li><li>ConcurrentHashMap默认拆分成16个小的HashTable集合，这样的话在多线程中，它们在执行put操作的时候，只要它们计算的index值不是落在同一个小的HashTable集合里面，这样的话是支持多线程同时去做put操作。</li><li>但是它有一个缺陷，就是每次put/get的时候，是需要计算两次index值的。因为它要计算我这个key是存放在哪一个小的HashTable里面，再计算在小的HashTable里面具体哪个位置。</li></ul></li><li>在JDK8中 <ul><li>ConcurrentHashMap的底层数据结构采用的和HashMap一样，即采用“数组+链表+红黑树”的形式。采用Synchronized+CAS+Node来保证并发安全的进行。他采用锁定头结点的方式降低了锁粒度。</li><li>线程安全的实现机制： <ul><li>初始化头结点时，并没有加锁，而是以CAS的方式进行原子替换。</li><li>插入数据时会进行加锁处理，但是锁的是头节点，而不是整个数数组，降低了锁的粒度，并发性能很好</li><li>扩容时会进行加锁操作，锁定的仍然是头节点。</li><li>查询数据时不会进行加锁，所以性能很好。</li><li>在扩容的时候,多个线程共同分担数据迁移任务,每个线程负责的迁移数量是 <code>(数组长度 &gt;&gt;&gt; 3) / CPU核心数</code></li></ul></li></ul></li></ul></li><li><p>ConcurrentHashMap 的 size()方法是线程安全的吗</p><ul><li>不是，ConcurrentHashMap 是弱一致性的，不能保证高并发环境下，size()返回和实际的存储的大小一致。</li></ul></li><li><p>LinkedListHashMap的底层</p><ul><li>为啥可以实现有序</li></ul></li><li><p>TreeMap</p><ul><li>TreeMap 的底层数据结构是一棵红黑树，它是一种自平衡的二叉查找树，具有以下特点： <ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色的。</li><li>每个叶子节点（NIL 节点）是黑色的。</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的。</li><li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li></ol></li><li>TreeMap 中的每个节点都包含三个属性：key、value 和 color。其中，key 和 value 分别表示键和值，color 表示节点的颜色，红色或黑色。TreeMap 中的节点按照键的自然顺序或者指定的比较器顺序进行排序，具有以下特点： <ol><li>对于任意节点 x，其左子树中所有节点的键都小于 x 的键，其右子树中所有节点的键都大于 x 的键。</li><li>对于任意节点 x，其左子树和右子树的高度差不超过 1。</li></ol></li><li>在 TreeMap 中，查找、插入、删除操作都是基于红黑树的基本操作实现的，具体实现方式如下： <ol><li>查找操作：从根节点开始，按照键的自然顺序或者指定的比较器顺序进行查找，直到找到对应的节点或者遇到 NIL 节点。</li><li>插入操作：从根节点开始，按照键的自然顺序或者指定的比较器顺序进行查找，找到插入位置后，将新节点插入到该位置，并进行颜色调整和旋转操作，保持红黑树的平衡性。</li><li>删除操作：从根节点开始，按照键的自然顺序或者指定的比较器顺序进行查找，找到要删除的节点后，根据其子节点的情况进行删除操作，并进行颜色调整和旋转操作，保持红黑树的平衡性。</li></ol></li><li>TreeMap为什么可以指定比较器（不指定比较器默认就是自然排序）进行排序？就是用到了红黑树的插入操作和查找操作。</li><li>ps：如果面试问你这问题，我倒觉得不比较把整个红黑树都讲了，主要提一下用到了红黑树，然受说一下为什么可以指定比较器（不指定比较器默认就是自然排序）进行排序这个问题的答案，我觉得够了。除非后面面试管细纹红黑树的结构细节。</li></ul></li><li><p>怎么确保一个集合不被修改</p><ul><li>Collections.unmodifiableCollection(Collection c)创建一个只读</li><li>如果被修改了会抛出java.lang.UnsupportedOperationException</li></ul></li></ul><h2 id="迭代器" tabindex="-1"><a class="header-anchor" href="#迭代器" aria-hidden="true">#</a> 迭代器</h2><ul><li>fail-fast机制 <ul><li>fail-fast 这种遍历方式是直接在容器上进行的，在遍历过程中，一旦发现数据被修改了，就会立刻抛出ConcurrentModificationExcetion异常从而遍历失败。常见使用fail-fast方式的容器有HashMap和ArrayList。</li><li>fail-safe这种遍历方式基于容器的一个克隆。因此在对容器中的内容进行修改不会影响遍历。常见使用fail-safe遍历的容器的有ConcurrentHashMap和CopyOnWriteArrayList。</li></ul></li><li>ListIterator和Iterator <ul><li>ListIterator可以增删改，Iterator只可删</li><li>ListIterator可以从顺序和逆序遍历，而Iterator只能顺序</li><li>ListIterator可以获取索引下标，Iterator不可以</li></ul></li><li>迭代器与普通for循环有什么区别 <ul><li>主要区别是迭代器可以在循环时候删除元素，而for不可以，会报错</li><li>Iterator没有索引下标，但是其实ListIterator可以获取索引下标，for是基于下标获取元素</li></ul></li></ul>',7),u=[r];function s(n,p){return i(),a("div",null,u)}const c=l(t,[["render",s],["__file","Java集合容器.html.vue"]]);export{c as default};
