const n=JSON.parse('{"key":"v-82c462ea","path":"/java/Java%E5%9F%BA%E7%A1%80.html","title":"Java基础","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-08-08T00:00:00.000Z","category":["java"],"tag":["Java基础","序列化","集合"],"description":"Java基础 java 基础 你怎么理解抽象类和接口的 抽象是对于某类事务，进行抽象，比如猫狗，可以抽象出一个动物类，是自下而上 而接口是定义一些规范，实现该接口的，就要按规范的来，是自上而下的 Java是编译型语言和解释型语言 编译：主要是体现在把Java代码编译成字节码 解释：主要体现在字节码解释为计算机可识别的机器码 String + 号 底层原理 StringBuilder().append() 八种基本数据类型有哪些 boolean占用空间： JVM对boolean的支持很有限，会用int代替boolean，如果是boolean数组，会转化为byte数组 所以占用空间情况为：boolean为4个字节，boolean数组，每一个元素一字节 有了基本数据类型为什么还要包装类型 泛型不支持基本数据类型 有的业务需要，比如，如果用基本数据类型，因为有初始值，就没法判断是没考试还是考试得了零分，而有了Integer类型，null代表没考试，0代表0分 JDK1.8 提供哪些新特性 自动装箱与自动拆箱 重载与重写的区别 equals 与 == 的区别 a=a+b 与 a+=b 有什么区别 final关键字的用法 try catch finally，try里有return，finally还执行么？ 重写equals方法为什么要重写HashCode方法 String、StringBuilder、StringBuffer的区别 String + 号的底层是啥 new StringBuilder(\\"\\").append String + 号是运算符重载吗 Java 不支持运算符重载 java四种引用 反射机制讲讲 运行状态中 对于任何一个类，能够知道所有属性和方法 对于任何一个对象，能够调用它的所有属性和方法 优缺点： 优点：动态性，灵活 缺点：性能稍微差点 创建对象有哪几种方式 如何获取Class方式 说说什么是 fail-fast？ 深拷贝和浅拷贝的区别 Excetion与Error的包结构 异常链 参考：“全栈2019”Java异常第十五章：异常链详解 - 掘金 (juejin.cn) 定义：捕获一个异常后抛出另一个异常，并且把原始异常信息保存下来，这被称为异常链。 异常构造函数，Throwable​(String message, Throwable cause)，catch原始异常后，抛出新的异常，原始异常信息e，作为新异常的第二个参数cause。 为啥要设计checkedException checked异常就是可以被处理（修复）的错误，unchecked异常其实就是无法处理（修复）的错误。 java的catch干的就是错误修复的事。 内部类 包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类 构造器（constructor）是否可被重写（override） 不能，只能被重载 重载的方法能否根据返回类型进行区分？为什么？ 不能，因为调用方法时候不能指定类型，那么编译器不知道你调用哪个方法 java是值传递还是引用传递 值传递：调用方法传递参数的拷贝副本 引用传递：调用方法传递参数的地址 区分值传递还是引用传递，看看传递的是副本还是地址 只有值传递 解释起来感觉挺麻烦的 基本数据类型，这个大家都懂的，肯定是值传递 而引用对象一直被误认为是引用传递，其实他在栈中拷贝了一个副本，这个副本指向了跟原引用对象的堆，这个时候，如果不想影响到原引用对象的内容，可以传进方法的时候再new一次申请一下堆的内存空间。 泛型 泛型机制：在编译期间，对于安全类型的检查机制 泛型擦除：泛型机制是在编译器这个层次完成的，生成字节码中不包含泛型信息，这些信息编译时就被删除掉了。 Java泛型为什么要做擦除，用真泛型不行？ 泛型是jdk5发布的，做泛型擦除而不做真泛型是为了兼容老代码吧。 两个同名方法，一个以Stirng为泛型，一个以Integer为泛型，算重载吗 参考：当泛型遇到重载_javaPie的博客-CSDN博客 不算重载，首先会编译不通过，在Java中泛型是伪泛型，编译器擦除后，两个方法的方法名和参数列表是同样的，编译器当然会拒绝编译。 java编译时多态和运行时多态 编译时多态，编译时期就知道执行多态方法的哪一个 方法重载是编译时多态，编译时根据参数列表就知道是调用多态方法哪一个 运行时多态，运行时才能确定调用多态方法哪一个 比如方法重写某些情况只有运行时候才能知道调用的是多态方法哪一个 Parent p = new Son(); p.toString()只有在运行时候才能知道调用的是Parent的toString()方法 private修饰的方法可以通过反射访问，那么private的意义是什么？ Class.forName和ClassLoader的区别 Class.forName得到的class是已经初始化完成的 Classloder.loaderClass得到的class是还没有链接的 Java静态方法可以被继承吗？可以被重写吗？ 可以被继承，不能被重写，但可以父类子类可以有一样的静态方法。 关于不能重写，如果子类写了一个静态方法和父类静态方法一样的方法，是不会报错的，这时候父类的静态方法和变量会被隐藏掉。但是如果，子类的静态方法写上@Override ，这时候编译会报错。因为不能够被重写。 为什么java的静态方法能被继承 - 编程语言 - 亿速云 (yisu.com) Java的父类静态方法可以被子类继承和重写（覆盖）吗？_毅一s的博客-CSDN博客_静态成员方法可以在子类和父类间覆写 怎么理解SPI和API API:一般情况下，都是由实现方来制定接口并完成对接口的不同实现 SPI:调用方指定接口，实现方去实现","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/bluesky-java-interview/java/Java%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"BlueSky的八股文"}],["meta",{"property":"og:title","content":"Java基础"}],["meta",{"property":"og:description","content":"Java基础 java 基础 你怎么理解抽象类和接口的 抽象是对于某类事务，进行抽象，比如猫狗，可以抽象出一个动物类，是自下而上 而接口是定义一些规范，实现该接口的，就要按规范的来，是自上而下的 Java是编译型语言和解释型语言 编译：主要是体现在把Java代码编译成字节码 解释：主要体现在字节码解释为计算机可识别的机器码 String + 号 底层原理 StringBuilder().append() 八种基本数据类型有哪些 boolean占用空间： JVM对boolean的支持很有限，会用int代替boolean，如果是boolean数组，会转化为byte数组 所以占用空间情况为：boolean为4个字节，boolean数组，每一个元素一字节 有了基本数据类型为什么还要包装类型 泛型不支持基本数据类型 有的业务需要，比如，如果用基本数据类型，因为有初始值，就没法判断是没考试还是考试得了零分，而有了Integer类型，null代表没考试，0代表0分 JDK1.8 提供哪些新特性 自动装箱与自动拆箱 重载与重写的区别 equals 与 == 的区别 a=a+b 与 a+=b 有什么区别 final关键字的用法 try catch finally，try里有return，finally还执行么？ 重写equals方法为什么要重写HashCode方法 String、StringBuilder、StringBuffer的区别 String + 号的底层是啥 new StringBuilder(\\"\\").append String + 号是运算符重载吗 Java 不支持运算符重载 java四种引用 反射机制讲讲 运行状态中 对于任何一个类，能够知道所有属性和方法 对于任何一个对象，能够调用它的所有属性和方法 优缺点： 优点：动态性，灵活 缺点：性能稍微差点 创建对象有哪几种方式 如何获取Class方式 说说什么是 fail-fast？ 深拷贝和浅拷贝的区别 Excetion与Error的包结构 异常链 参考：“全栈2019”Java异常第十五章：异常链详解 - 掘金 (juejin.cn) 定义：捕获一个异常后抛出另一个异常，并且把原始异常信息保存下来，这被称为异常链。 异常构造函数，Throwable​(String message, Throwable cause)，catch原始异常后，抛出新的异常，原始异常信息e，作为新异常的第二个参数cause。 为啥要设计checkedException checked异常就是可以被处理（修复）的错误，unchecked异常其实就是无法处理（修复）的错误。 java的catch干的就是错误修复的事。 内部类 包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类 构造器（constructor）是否可被重写（override） 不能，只能被重载 重载的方法能否根据返回类型进行区分？为什么？ 不能，因为调用方法时候不能指定类型，那么编译器不知道你调用哪个方法 java是值传递还是引用传递 值传递：调用方法传递参数的拷贝副本 引用传递：调用方法传递参数的地址 区分值传递还是引用传递，看看传递的是副本还是地址 只有值传递 解释起来感觉挺麻烦的 基本数据类型，这个大家都懂的，肯定是值传递 而引用对象一直被误认为是引用传递，其实他在栈中拷贝了一个副本，这个副本指向了跟原引用对象的堆，这个时候，如果不想影响到原引用对象的内容，可以传进方法的时候再new一次申请一下堆的内存空间。 泛型 泛型机制：在编译期间，对于安全类型的检查机制 泛型擦除：泛型机制是在编译器这个层次完成的，生成字节码中不包含泛型信息，这些信息编译时就被删除掉了。 Java泛型为什么要做擦除，用真泛型不行？ 泛型是jdk5发布的，做泛型擦除而不做真泛型是为了兼容老代码吧。 两个同名方法，一个以Stirng为泛型，一个以Integer为泛型，算重载吗 参考：当泛型遇到重载_javaPie的博客-CSDN博客 不算重载，首先会编译不通过，在Java中泛型是伪泛型，编译器擦除后，两个方法的方法名和参数列表是同样的，编译器当然会拒绝编译。 java编译时多态和运行时多态 编译时多态，编译时期就知道执行多态方法的哪一个 方法重载是编译时多态，编译时根据参数列表就知道是调用多态方法哪一个 运行时多态，运行时才能确定调用多态方法哪一个 比如方法重写某些情况只有运行时候才能知道调用的是多态方法哪一个 Parent p = new Son(); p.toString()只有在运行时候才能知道调用的是Parent的toString()方法 private修饰的方法可以通过反射访问，那么private的意义是什么？ Class.forName和ClassLoader的区别 Class.forName得到的class是已经初始化完成的 Classloder.loaderClass得到的class是还没有链接的 Java静态方法可以被继承吗？可以被重写吗？ 可以被继承，不能被重写，但可以父类子类可以有一样的静态方法。 关于不能重写，如果子类写了一个静态方法和父类静态方法一样的方法，是不会报错的，这时候父类的静态方法和变量会被隐藏掉。但是如果，子类的静态方法写上@Override ，这时候编译会报错。因为不能够被重写。 为什么java的静态方法能被继承 - 编程语言 - 亿速云 (yisu.com) Java的父类静态方法可以被子类继承和重写（覆盖）吗？_毅一s的博客-CSDN博客_静态成员方法可以在子类和父类间覆写 怎么理解SPI和API API:一般情况下，都是由实现方来制定接口并完成对接口的不同实现 SPI:调用方指定接口，实现方去实现"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"blueSky"}],["meta",{"property":"article:tag","content":"Java基础"}],["meta",{"property":"article:tag","content":"序列化"}],["meta",{"property":"article:tag","content":"集合"}],["meta",{"property":"article:published_time","content":"2023-08-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java基础\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"blueSky\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"java 基础","slug":"java-基础","link":"#java-基础","children":[]},{"level":2,"title":"序列化","slug":"序列化","link":"#序列化","children":[]}],"git":{},"readingTime":{"minutes":7.85,"words":2354},"filePathRelative":"java/Java基础.md","localizedDate":"August 8, 2023","excerpt":"<h1> Java基础</h1>\\n<h2> java 基础</h2>\\n<ul>\\n<li>\\n<p>你怎么理解抽象类和接口的</p>\\n<ul>\\n<li>抽象是对于某类事务，进行抽象，比如猫狗，可以抽象出一个动物类，是自下而上</li>\\n<li>而接口是定义一些规范，实现该接口的，就要按规范的来，是自上而下的</li>\\n</ul>\\n</li>\\n<li>\\n<p>Java是编译型语言和解释型语言</p>\\n<ul>\\n<li>编译：主要是体现在把Java代码编译成字节码</li>\\n<li>解释：主要体现在字节码解释为计算机可识别的机器码</li>\\n</ul>\\n</li>\\n<li>\\n<p>String + 号 底层原理</p>\\n<ul>\\n<li>StringBuilder().append()</li>\\n</ul>\\n</li>\\n<li>\\n<p>八种基本数据类型有哪些</p>\\n<ul>\\n<li>boolean占用空间：\\n<ul>\\n<li>JVM对boolean的支持很有限，会用int代替boolean，如果是boolean数组，会转化为byte数组</li>\\n<li>所以占用空间情况为：boolean为4个字节，boolean数组，每一个元素一字节</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>有了基本数据类型为什么还要包装类型</p>\\n<ul>\\n<li>泛型不支持基本数据类型</li>\\n<li>有的业务需要，比如，如果用基本数据类型，因为有初始值，就没法判断是没考试还是考试得了零分，而有了Integer类型，null代表没考试，0代表0分</li>\\n</ul>\\n</li>\\n<li>\\n<p>JDK1.8 提供哪些新特性</p>\\n</li>\\n<li>\\n<p>自动装箱与自动拆箱</p>\\n</li>\\n<li>\\n<p>重载与重写的区别</p>\\n</li>\\n<li>\\n<p>equals 与 == 的区别</p>\\n</li>\\n<li>\\n<p>a=a+b 与 a+=b 有什么区别</p>\\n</li>\\n<li>\\n<p>final关键字的用法</p>\\n</li>\\n<li>\\n<p>try catch finally，try里有return，finally还执行么？</p>\\n</li>\\n<li>\\n<p>重写equals方法为什么要重写HashCode方法</p>\\n</li>\\n<li>\\n<p>String、StringBuilder、StringBuffer的区别</p>\\n</li>\\n<li>\\n<p>String + 号的底层是啥</p>\\n<ul>\\n<li>new StringBuilder(\\"\\").append</li>\\n</ul>\\n</li>\\n<li>\\n<p>String + 号是运算符重载吗</p>\\n<ul>\\n<li>Java 不支持运算符重载</li>\\n</ul>\\n</li>\\n<li>\\n<p>java四种引用</p>\\n</li>\\n<li>\\n<p>反射机制讲讲</p>\\n<ul>\\n<li>运行状态中\\n<ul>\\n<li>对于任何一个类，能够知道所有属性和方法</li>\\n<li>对于任何一个对象，能够调用它的所有属性和方法</li>\\n</ul>\\n</li>\\n<li>优缺点：\\n<ul>\\n<li>优点：动态性，灵活</li>\\n<li>缺点：性能稍微差点</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>创建对象有哪几种方式</p>\\n</li>\\n<li>\\n<p>如何获取Class方式</p>\\n</li>\\n<li>\\n<p>说说什么是 fail-fast？</p>\\n</li>\\n<li>\\n<p>深拷贝和浅拷贝的区别</p>\\n</li>\\n<li>\\n<p>Excetion与Error的包结构</p>\\n</li>\\n<li>\\n<p>异常链</p>\\n<ul>\\n<li>参考：<a href=\\"https://juejin.cn/post/6844903779641327630\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">“全栈2019”Java异常第十五章：异常链详解 - 掘金 (juejin.cn)</a></li>\\n<li>定义：<strong>捕获一个异常后抛出另一个异常，并且把原始异常信息保存下来，这被称为异常链。</strong></li>\\n<li>异常构造函数，<strong>Throwable​(String message, Throwable cause)</strong>，catch原始异常后，抛出新的异常，原始异常信息e，作为新异常的第二个参数cause。</li>\\n</ul>\\n</li>\\n<li>\\n<p>为啥要设计checkedException</p>\\n<ul>\\n<li>checked异常就是可以被处理（修复）的错误，unchecked异常其实就是无法处理（修复）的错误。</li>\\n<li>java的catch干的就是错误修复的事。</li>\\n</ul>\\n</li>\\n<li>\\n<p>内部类</p>\\n<ul>\\n<li>包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类</li>\\n</ul>\\n</li>\\n<li>\\n<p>构造器（constructor）是否可被重写（override）</p>\\n<ul>\\n<li>不能，只能被重载</li>\\n</ul>\\n</li>\\n<li>\\n<p>重载的方法能否根据返回类型进行区分？为什么？</p>\\n<ul>\\n<li>不能，因为调用方法时候不能指定类型，那么编译器不知道你调用哪个方法</li>\\n</ul>\\n</li>\\n<li>\\n<p>java是值传递还是引用传递</p>\\n<ul>\\n<li>值传递：调用方法传递参数的拷贝副本</li>\\n<li>引用传递：调用方法传递参数的地址</li>\\n<li>区分值传递还是引用传递，看看传递的是副本还是地址</li>\\n<li>只有值传递\\n<ul>\\n<li>解释起来感觉挺麻烦的\\n<ul>\\n<li>基本数据类型，这个大家都懂的，肯定是值传递</li>\\n<li>而引用对象一直被误认为是引用传递，其实他在栈中拷贝了一个副本，这个副本指向了跟原引用对象的堆，这个时候，如果不想影响到原引用对象的内容，可以传进方法的时候再new一次申请一下堆的内存空间。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>泛型</p>\\n<ul>\\n<li>泛型机制：在编译期间，对于安全类型的检查机制</li>\\n<li>泛型擦除：泛型机制是在编译器这个层次完成的，生成字节码中不包含泛型信息，这些信息编译时就被删除掉了。</li>\\n</ul>\\n</li>\\n<li>\\n<p>Java泛型为什么要做擦除，用真泛型不行？</p>\\n<ul>\\n<li>泛型是jdk5发布的，做泛型擦除而不做真泛型是为了兼容老代码吧。</li>\\n</ul>\\n</li>\\n<li>\\n<p>两个同名方法，一个以Stirng为泛型，一个以Integer为泛型，算重载吗</p>\\n<ul>\\n<li>参考：<a href=\\"https://blog.csdn.net/evilcry2012/article/details/54378125\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">当泛型遇到重载_javaPie的博客-CSDN博客</a></li>\\n<li>不算重载，首先会编译不通过，在Java中泛型是伪泛型，编译器擦除后，两个方法的方法名和参数列表是同样的，编译器当然会拒绝编译。</li>\\n</ul>\\n</li>\\n<li>\\n<p>java编译时多态和运行时多态</p>\\n<ul>\\n<li>编译时多态，编译时期就知道执行多态方法的哪一个\\n<ul>\\n<li>方法重载是编译时多态，编译时根据参数列表就知道是调用多态方法哪一个</li>\\n</ul>\\n</li>\\n<li>运行时多态，运行时才能确定调用多态方法哪一个\\n<ul>\\n<li>比如方法重写某些情况只有运行时候才能知道调用的是多态方法哪一个</li>\\n<li>Parent p = new Son();  p.toString()只有在运行时候才能知道调用的是Parent的toString()方法</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>private修饰的方法可以通过反射访问，那么private的意义是什么？</p>\\n</li>\\n<li>\\n<p>Class.forName和ClassLoader的区别</p>\\n<ul>\\n<li>Class.forName得到的class是已经初始化完成的</li>\\n<li>Classloder.loaderClass得到的class是还没有链接的</li>\\n</ul>\\n</li>\\n<li>\\n<p>Java静态方法可以被继承吗？可以被重写吗？</p>\\n<ul>\\n<li>可以被继承，不能被重写，但可以父类子类可以有一样的静态方法。</li>\\n<li>关于不能重写，如果子类写了一个静态方法和父类静态方法一样的方法，是不会报错的，这时候父类的静态方法和变量会被隐藏掉。但是如果，子类的静态方法写上@Override ，这时候编译会报错。因为不能够被重写。</li>\\n<li><a href=\\"https://www.yisu.com/zixun/130636.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">为什么java的静态方法能被继承 - 编程语言 - 亿速云 (yisu.com)</a></li>\\n<li><a href=\\"https://blog.csdn.net/qq_34826261/article/details/101039492\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Java的父类静态方法可以被子类继承和重写（覆盖）吗？_毅一s的博客-CSDN博客_静态成员方法可以在子类和父类间覆写</a></li>\\n</ul>\\n</li>\\n<li>\\n<p>怎么理解SPI和API</p>\\n<ul>\\n<li>API:一般情况下，都是由实现方来制定接口并完成对接口的不同实现</li>\\n<li>SPI:调用方指定接口，实现方去实现</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{n as data};
