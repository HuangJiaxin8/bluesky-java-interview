import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as u,c as o,b as l,d as i,e as a,f as n}from"./app-c550aa6e.js";const s={},p=l("h1",{id:"java基础",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#java基础","aria-hidden":"true"},"#"),i(" Java基础")],-1),c=l("h2",{id:"java-基础",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#java-基础","aria-hidden":"true"},"#"),i(" java 基础")],-1),d=n("<li><p>你怎么理解抽象类和接口的</p><ul><li>抽象是对于某类事务，进行抽象，比如猫狗，可以抽象出一个动物类，是自下而上</li><li>而接口是定义一些规范，实现该接口的，就要按规范的来，是自上而下的</li></ul></li><li><p>Java是编译型语言和解释型语言</p><ul><li>编译：主要是体现在把Java代码编译成字节码</li><li>解释：主要体现在字节码解释为计算机可识别的机器码</li></ul></li><li><p>String + 号 底层原理</p><ul><li>StringBuilder().append()</li></ul></li><li><p>八种基本数据类型有哪些</p><ul><li>boolean占用空间： <ul><li>JVM对boolean的支持很有限，会用int代替boolean，如果是boolean数组，会转化为byte数组</li><li>所以占用空间情况为：boolean为4个字节，boolean数组，每一个元素一字节</li></ul></li></ul></li><li><p>有了基本数据类型为什么还要包装类型</p><ul><li>泛型不支持基本数据类型</li><li>有的业务需要，比如，如果用基本数据类型，因为有初始值，就没法判断是没考试还是考试得了零分，而有了Integer类型，null代表没考试，0代表0分</li></ul></li><li><p>JDK1.8 提供哪些新特性</p></li><li><p>自动装箱与自动拆箱</p></li><li><p>重载与重写的区别</p></li><li><p>equals 与 == 的区别</p></li><li><p>a=a+b 与 a+=b 有什么区别</p></li><li><p>final关键字的用法</p></li><li><p>try catch finally，try里有return，finally还执行么？</p></li><li><p>重写equals方法为什么要重写HashCode方法</p></li><li><p>String、StringBuilder、StringBuffer的区别</p></li><li><p>String + 号的底层是啥</p><ul><li>new StringBuilder(&quot;&quot;).append</li></ul></li><li><p>String + 号是运算符重载吗</p><ul><li>Java 不支持运算符重载</li></ul></li><li><p>java四种引用</p></li><li><p>反射机制讲讲</p><ul><li>运行状态中 <ul><li>对于任何一个类，能够知道所有属性和方法</li><li>对于任何一个对象，能够调用它的所有属性和方法</li></ul></li><li>优缺点： <ul><li>优点：动态性，灵活</li><li>缺点：性能稍微差点</li></ul></li></ul></li><li><p>创建对象有哪几种方式</p></li><li><p>如何获取Class方式</p></li><li><p>说说什么是 fail-fast？</p></li><li><p>深拷贝和浅拷贝的区别</p></li><li><p>Excetion与Error的包结构</p></li>",23),_=l("p",null,"异常链",-1),h={href:"https://juejin.cn/post/6844903779641327630",target:"_blank",rel:"noopener noreferrer"},v=l("li",null,[i("定义："),l("strong",null,"捕获一个异常后抛出另一个异常，并且把原始异常信息保存下来，这被称为异常链。")],-1),b=l("li",null,[i("异常构造函数，"),l("strong",null,"Throwable​(String message, Throwable cause)"),i("，catch原始异常后，抛出新的异常，原始异常信息e，作为新异常的第二个参数cause。")],-1),S=n("<li><p>为啥要设计checkedException</p><ul><li>checked异常就是可以被处理（修复）的错误，unchecked异常其实就是无法处理（修复）的错误。</li><li>java的catch干的就是错误修复的事。</li></ul></li><li><p>内部类</p><ul><li>包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类</li></ul></li><li><p>构造器（constructor）是否可被重写（override）</p><ul><li>不能，只能被重载</li></ul></li><li><p>重载的方法能否根据返回类型进行区分？为什么？</p><ul><li>不能，因为调用方法时候不能指定类型，那么编译器不知道你调用哪个方法</li></ul></li><li><p>java是值传递还是引用传递</p><ul><li>值传递：调用方法传递参数的拷贝副本</li><li>引用传递：调用方法传递参数的地址</li><li>区分值传递还是引用传递，看看传递的是副本还是地址</li><li>只有值传递 <ul><li>解释起来感觉挺麻烦的 <ul><li>基本数据类型，这个大家都懂的，肯定是值传递</li><li>而引用对象一直被误认为是引用传递，其实他在栈中拷贝了一个副本，这个副本指向了跟原引用对象的堆，这个时候，如果不想影响到原引用对象的内容，可以传进方法的时候再new一次申请一下堆的内存空间。</li></ul></li></ul></li></ul></li><li><p>泛型</p><ul><li>泛型机制：在编译期间，对于安全类型的检查机制</li><li>泛型擦除：泛型机制是在编译器这个层次完成的，生成字节码中不包含泛型信息，这些信息编译时就被删除掉了。</li></ul></li><li><p>Java泛型为什么要做擦除，用真泛型不行？</p><ul><li>泛型是jdk5发布的，做泛型擦除而不做真泛型是为了兼容老代码吧。</li></ul></li>",7),f=l("p",null,"两个同名方法，一个以Stirng为泛型，一个以Integer为泛型，算重载吗",-1),j={href:"https://blog.csdn.net/evilcry2012/article/details/54378125",target:"_blank",rel:"noopener noreferrer"},g=l("li",null,"不算重载，首先会编译不通过，在Java中泛型是伪泛型，编译器擦除后，两个方法的方法名和参数列表是同样的，编译器当然会拒绝编译。",-1),J=n("<li><p>java编译时多态和运行时多态</p><ul><li>编译时多态，编译时期就知道执行多态方法的哪一个 <ul><li>方法重载是编译时多态，编译时根据参数列表就知道是调用多态方法哪一个</li></ul></li><li>运行时多态，运行时才能确定调用多态方法哪一个 <ul><li>比如方法重写某些情况只有运行时候才能知道调用的是多态方法哪一个</li><li>Parent p = new Son(); p.toString()只有在运行时候才能知道调用的是Parent的toString()方法</li></ul></li></ul></li><li><p>private修饰的方法可以通过反射访问，那么private的意义是什么？</p></li><li><p>Class.forName和ClassLoader的区别</p><ul><li>Class.forName得到的class是已经初始化完成的</li><li>Classloder.loaderClass得到的class是还没有链接的</li></ul></li>",3),I=l("p",null,"Java静态方法可以被继承吗？可以被重写吗？",-1),x=l("li",null,"可以被继承，不能被重写，但可以父类子类可以有一样的静态方法。",-1),m=l("li",null,"关于不能重写，如果子类写了一个静态方法和父类静态方法一样的方法，是不会报错的，这时候父类的静态方法和变量会被隐藏掉。但是如果，子类的静态方法写上@Override ，这时候编译会报错。因为不能够被重写。",-1),D={href:"https://www.yisu.com/zixun/130636.html",target:"_blank",rel:"noopener noreferrer"},E={href:"https://blog.csdn.net/qq_34826261/article/details/101039492",target:"_blank",rel:"noopener noreferrer"},N=l("li",null,[l("p",null,"怎么理解SPI和API"),l("ul",null,[l("li",null,"API:一般情况下，都是由实现方来制定接口并完成对接口的不同实现"),l("li",null,"SPI:调用方指定接口，实现方去实现")])],-1),V=n('<h2 id="序列化" tabindex="-1"><a class="header-anchor" href="#序列化" aria-hidden="true">#</a> 序列化</h2><ul><li>为什么要序列化和反序列化 <ul><li>当要实现对象的进程通信的时候，需要用到序列化</li><li>因为网络通信一般是通过二进制传输</li><li>通过序列化，把对象转化为字节序列，从而满足网络传输条件</li></ul></li><li>Java序列化相关的API <ul><li>java.io.ObjectOutputStream#writeObject(Object obj)</li><li>java.io.ObjectInputStream#readObject()</li></ul></li><li>Java实现序列化的方式有哪几种 <ul><li>实现Serialize接口，该接口是个空接口</li><li>实现Externalizable接口，该接口有两个方法，writeExternal，readExternal</li></ul></li><li>不想某个类的元素被序列化怎么办 <ul><li>@transient</li><li>实现了Externalizable 接口，程序员可以控制</li></ul></li><li>Externalizable接口和Serializable接口的区别 <ul><li>实现差异： <ul><li>Serializable 是JVM帮我们实现的，Externalizable需要我们自己写读写两个接口方法</li></ul></li><li>可控性差异： <ul><li>Externalizable 需要我们实现序列号反序列号接口方法，这个过程，具体序列哪个属性可控</li></ul></li><li>如果没有实现，会抛出异常</li></ul></li><li>为什么要序列化ID，或者说序列化ID的作用 <ul><li>在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较</li><li>如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常</li><li>为了安全，怕在网络传输过程中，被黑客串改我们对象，通过反序列化ID可以判断是否被串改。</li></ul></li><li>序列化ID不写有问题吗 <ul><li>Java序列化机制会根据编译时的class自动生成一个serialVersionUID作为序列化版本比较，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID</li><li>当我们编写一个类时，随着时间的推移，我们因为需求改动，需要在本地类中添加其他的字段，这个时候再反序列化时便会出现serialVersionUID不一致，导致反序列化失败</li><li>那么如何解决呢？便是在本地类中添加一个“serialVersionUID”变量，值保持不变，便可以进行序列化和反序列化。</li></ul></li><li>序列化ID不同类可以用同一个吗 <ul><li>可以，序列化反序列号只是针对于一个类，所以不同类使用同一个序列化ID其实没啥影响</li></ul></li><li>String有没有实现序列化？枚举呢？ <ul><li>都有实现，都实现了Serialize接口</li></ul></li><li>Java序列化和JSON序列化有什么区别 <ul><li>java序列化那么只能作用在java程序之间传输，是语言强相关的。而JSON序列化跟语言无关。</li><li>JSON序列化的可读性是比较好的。</li><li>JSON序列化就是将数据对象转换成JSON字符串，抛弃了类型信息，所以反序列化的时候要提供类型信息才能准确反序列化。</li></ul></li></ul>',2);function k(O,w){const e=r("ExternalLinkIcon");return u(),o("div",null,[p,c,l("ul",null,[d,l("li",null,[_,l("ul",null,[l("li",null,[i("参考："),l("a",h,[i("“全栈2019”Java异常第十五章：异常链详解 - 掘金 (juejin.cn)"),a(e)])]),v,b])]),S,l("li",null,[f,l("ul",null,[l("li",null,[i("参考："),l("a",j,[i("当泛型遇到重载_javaPie的博客-CSDN博客"),a(e)])]),g])]),J,l("li",null,[I,l("ul",null,[x,m,l("li",null,[l("a",D,[i("为什么java的静态方法能被继承 - 编程语言 - 亿速云 (yisu.com)"),a(e)])]),l("li",null,[l("a",E,[i("Java的父类静态方法可以被子类继承和重写（覆盖）吗？_毅一s的博客-CSDN博客_静态成员方法可以在子类和父类间覆写"),a(e)])])])]),N]),V])}const y=t(s,[["render",k],["__file","Java基础.html.vue"]]);export{y as default};
