import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as u,o as r,c as n,b as i,d as l,e as s,f as d}from"./app-c550aa6e.js";const t={},o=d('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><ul><li><p>为什么使用缓存</p><ul><li>提高读写性能</li><li>Redis读写性能比Mysql好很多，把Mysql的热点数据缓存到Redis，减轻Mysql的压力。</li></ul></li><li><p>什么是Redis？</p><ul><li>开源的、基于内存、多种数据结构的存储系统</li><li>可以作为数据库、缓存、消息中间件</li><li>支持的数据结构有： <ul><li>string、hash、list、set、zset(sorted set)、除此之外，还有bitmap、hyperlogLog和地理空间</li></ul></li></ul></li><li><p>Redis的优点有哪些？（为什么使用Redis）</p><ul><li>c语言实现，效率高</li><li>纯内存操作</li><li>单线程模型，可以避免上下文切换</li><li>非阻塞IO复用模型</li><li>丰富的数据结构</li></ul></li><li><p>说一下Redis的优缺点？</p><ul><li>优点： <ul><li>速度快，基于内存</li><li>支持丰富的数据结构</li><li>有持久化存储方案</li><li>高可用，支持集群</li></ul></li><li>缺点： <ul><li>内存数据库，内存的瓶颈</li></ul></li></ul></li><li><p>为什么选用Redis而不是Memcache？</p><ul><li>Redis支持多种数据结构，Memcache不支持</li><li>Redis支持虚拟内存，物理内存用完之后，把内存放到磁盘上</li><li>Redis有持久化机制，Memcache一挂掉后，数据就没了</li><li>Redis原生支持集群，Memcache没原生集群，需要依赖客户端实现</li></ul></li><li><p>Redis的数据类型以及使用场景</p><ul><li>常用的数据类型： <ul><li>String <ul><li>最常规的get/set操作，value可以是String也可以是数字。</li><li>使用场景：微博粉丝数</li></ul></li><li>Hash <ul><li>value存放结构化的对象，比较方便操作其中某个值</li></ul></li><li>List <ul><li>可以做一些简单的消息队列功能，最新回复功能</li></ul></li><li>Set <ul><li>Set是不重复的集合，利用交集并集差集，计算共同好友，共同爱好。</li></ul></li><li>zset/Sorted Set <ul><li>Sorted Set 多了一个权重参数Score，集合中的元素按Score排列。可以做排行榜应用，也可以来做一些延时任务</li></ul></li></ul></li><li>不常用的数据类型： <ul><li>Bitmap</li><li>HyperlogLog</li><li>Geospatial</li></ul></li></ul></li><li><p>Redis 缓存（集中式缓存）和JVM缓存（本地缓存）有什么区别</p><ul><li>本地缓存，没有成熟的超时机制，而Redis缓存是第三方中间件，提供着成熟的超时机制。</li><li>本地缓存只能用于单进程，而Redis缓存可以用于分布式。</li><li>本地缓存不支持持久化，进程结束，缓存就失效。而Redis缓存支持持久化。</li></ul></li><li><p>什么情况下可能会导致 Redis 阻塞？</p><ul><li>内部： <ul><li>Redis主机的CPU过载</li><li>数据持久化占用资源过多</li></ul></li><li>外部： <ul><li>网络问题</li><li>内存问题</li></ul></li></ul></li><li><p>Redis 如何解决 key 冲突？</p><ul><li>后一个key会覆盖前一个key，建议取名的时候key就要分开好</li></ul></li><li><p>一个字符串类型的值能存储最大容量是多少</p><ul><li>512M</li></ul></li><li><p>Redis如何做大量数据插入</p><ul><li>Redis2.6开始,redis-cli支持一种新的被称之为pipe mode的新模式,用于执行大量数据插入的工作。</li></ul></li><li><p>Redis 哈希槽</p></li></ul><p>Redis中的Hash槽是一种将键映射到槽位的机制，它可以将一个大的键空间划分为多个小的槽位，通过哈希函数将键映射到对应的槽位中，从而实现快速查找和访问。Redis中的Hash槽适用于键值对数量非常大的情况，可以有效地提高Redis的性能。</p><p>Redis中的Hash槽具体工作流程如下：</p><ol><li>创建Hash槽：在Redis启动时，会创建一个大小为2的n次方的Hash槽（默认为2的16次方），每个Hash槽对应一个哈希值的范围。</li><li>计算哈希值：当客户端向Redis发送一个键时，Redis会将这个键通过哈希函数计算出一个哈希值。</li><li>映射到槽位：Redis使用哈希值与Hash槽的大小进行取模计算，得到一个槽位编号。这个槽位编号就是这个键对应的Hash槽的位置。</li><li>槽位冲突的解决：如果两个键被哈希函数映射到了同一个槽位，那么就会出现槽位冲突。Redis使用链表的方式来解决槽位冲突，将多个键值对存储在同一个槽位对应的链表中。这个链表上的每个节点包含了一个键值对。（拉链法）</li><li>扩容：当Hash槽使用率达到一定的阈值时，Redis会自动地对Hash槽进行扩容，将Hash槽的大小扩大为原来的两倍，并将所有键重新映射到新的Hash槽中。</li></ol><p>使用Hash槽可以将键的哈希值映射到不同的槽位上，从而实现高效的键值对查找和访问。同时，Hash槽还具有自动扩容的功能，可以动态地适应数据量的变化，保证Redis的性能和可用性。</p><ul><li>疑问：redis开启了HASH槽功能，那么我用客户端链接工具查看redis的某个key，那么要输入的是我原先设置的key还是hash槽经过hash算法后得到的key <ul><li>在Redis中，开启了Hash槽后，客户端工具访问Redis时，仍然需要使用原始的键名来进行访问。当客户端发送一个键到Redis时，Redis会自动将该键散列为一个哈希值，并将哈希值映射到对应的Hash槽上。在Redis中，键名和哈希值之间的映射关系是自动进行的，客户端不需要直接操作哈希值，只需要使用原始的键名。</li></ul></li></ul><h2 id="线程模型" tabindex="-1"><a class="header-anchor" href="#线程模型" aria-hidden="true">#</a> 线程模型</h2><ul><li><p>说说Redis的线程模型</p><ul><li>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。</li><li>它的组成结构为4部分：多个套接字、 IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 <ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul></li></ul></li><li><p>Redis 为什么使用单线程模型</p><ul><li>因为Redis使用单线程模型效率还是很高</li><li>接着就说下面的优点</li></ul></li><li><p>Redis 使用单线程模型效率为什么还很高</p><ul><li>C语言实现</li><li>纯内存操作</li><li>基于非阻塞IO复用模型</li><li>单线程可以避免上下文切换</li></ul></li><li><p>为什么Redis的操作是原子性的</p><ul><li>因为是单线程所以操作是原子性的</li></ul></li></ul><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化" aria-hidden="true">#</a> 持久化</h2><ul><li>Redis持久化方式有哪些 <ul><li>快照RDB和只追加文件AOF</li><li>RDB: <ul><li>时间间隔内将内存中的数据集快照写入磁盘，它恢复时是将快照文件直接读到内存里。</li><li>性能好， fork 子进程来完成写操作，让主进程继续处理命令</li><li>文件：dump.rdb</li><li>优势：适合大规模的数据恢复，适合一些对于数据完整性要求不高的情况，因为是二进制保存，所以文件小</li><li>劣势：在一定时间间隔做一次备份，最后一次down掉后，会丢失最后一次快照后的所有修改</li></ul></li><li>AOF:以日志的形式来记录每个写操作，读操作不记录，只许追加文件不可改写文件，Redis启动之初会读取该文件重新构建数据 <ul><li>优势： <ul><li>每修改同步：<code>appendfsync always</code> 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li><li>每秒同步：<code>appendfsync everysec</code> 异步操作，每秒记录，如果一秒内宕机，会有数据丢失</li><li>不同步：<code>appendfsync no</code> 从不同步</li></ul></li><li>劣势： <ul><li>aof文件比较大，恢复比较慢</li></ul></li></ul></li></ul></li><li>持久化方式有两种，怎么选择呢 <ul><li>数据比较重要的话，同时能接受数分钟的数据丢失，可以只使用RDB</li><li>用作内存数据库，要使用Redis持久化，建议RDB和AOF都开启，RDB适合做数据备份，AOF能保证数据不丢失，重启后，优先加载AOF</li></ul></li></ul><h2 id="过期键问题" tabindex="-1"><a class="header-anchor" href="#过期键问题" aria-hidden="true">#</a> 过期键问题</h2><ul><li>Redis过期键删除策略 <ul><li>惰性删除和定期删除两种策略配合使用</li><li>惰性删除：不会主动删除，每次访问数据的时候，检查当前键是否过期，过期执行删除返回null。 <ul><li>优点：简单</li><li>缺点：删除不及时，对内存不友好</li></ul></li><li>定期删除：Redis会周期性的随机测试一批设置了过期的键进行处理，发现过期的键就删除。 <ul><li>优点：能较有效的删除过期键</li><li>缺点：难以确定删除频率和时长，执行太频繁，对cpu不友好，太少的话，对内存不友好。</li></ul></li><li>定时删除：给key创建过期时间的同时，创建定时器，定时器在时间到的时候，对键进行删除。 <ul><li>优点：对内存最友好</li><li>缺点：定时器对CPU不友好</li></ul></li></ul></li></ul><h2 id="内存淘汰" tabindex="-1"><a class="header-anchor" href="#内存淘汰" aria-hidden="true">#</a> 内存淘汰</h2><ul><li><p>Redis内存满的情况下，怎么办</p><ul><li>Redis内存满了，是因为受到了一些硬件内存的限制，当我们redis一旦满的时候，会触发缓存淘汰策略，会把最近不常使用的缓存给清除掉。有lru，lfu缓存淘汰算法。</li></ul></li><li><p>Redis报内存不足怎么办</p><ul><li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存；</li><li>使用 Redis 集群模式，提高存储量。</li><li>设置缓存淘汰策略，提高内存的使用效率；</li></ul></li><li><p>内存淘汰机制/内存淘汰策略：</p><p><strong>Redisv4.0前提供 6种数据淘汰策略</strong>：</p><ul><li>volatile-lru：利用LRU算法移除设置了过期时间的key (LRU:最近最少使用 Least Recently Used )</li><li>allkeys-lru：移除最近最少使用的key（这个是最常用的）</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>volatile-ttl：淘汰将要过期的key</li><li>no-eviction：禁止删除数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 默认</li></ul><p><strong>Redisv4.0后增加以下两种</strong>：</p><ul><li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used 最不经常使用的)算法，也就是最频繁被访问的数据将来最有可能被访问到)</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li></ul><p>内存淘汰策略可以通过配置文件来修改，Redis.conf对应的配置项是maxmemory-policy 修改对应的值就行，默认是no-eviction。</p></li></ul><h2 id="数据一致性" tabindex="-1"><a class="header-anchor" href="#数据一致性" aria-hidden="true">#</a> 数据一致性</h2><ul><li><p>缓存和数据库谁先更新</p><ul><li>对于数据库和缓存的关系，大体上有4个： <ul><li>先更新数据库，在更新缓存</li><li>先更新缓存，再更新数据库</li><li>先删除缓存，后更新数据库</li><li>先更新数据库，再删除缓存</li></ul></li><li>第一第二种，一般没人用。 <ul><li>第一种存在问题是：并发更新数据库，缓存会有脏数据。</li><li>第二种更新缓存成功，但数据库更新失败，会造成数据不一致。</li></ul></li></ul></li><li><p>Redis缓存与db数据不一致问题如何解决</p><ul><li>先删除缓存，后更新数据库 <ul><li>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作） <ul><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存在</li><li>请求B去数据库查询得到旧值</li><li>请求B将旧值写入缓存</li><li>请求A将新值写入数据库</li></ul></li><li>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</li></ul></li><li>先更新数据库，再删除缓存 <ul><li>该方案也有问题， <ul><li>缓存失效，线程B读取数据库旧值</li><li>线程A更新数据库</li><li>线程A删除缓存</li><li>线程B更新缓存</li></ul></li><li>以上出现的情况概率很低。在不想做过多设计，该方案确实能满足大部分场景</li></ul></li></ul></li></ul>',18),c={id:"答案一-延时双删",tabindex:"-1"},p=i("a",{class:"header-anchor",href:"#答案一-延时双删","aria-hidden":"true"},"#",-1),h={href:"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=%E7%AD%94%E6%A1%88%E4%B8%80%EF%BC%9A%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0",target:"_blank",rel:"noopener noreferrer"},R=i("ol",null,[i("li",null,"先淘汰缓存"),i("li",null,"再写数据库"),i("li",null,"休眠1秒，再次淘汰缓存。这么做，可以将1秒内所造成的缓存脏数据，再次删除。")],-1),g={id:"答案二-更新与读取操作进行异步串行化",tabindex:"-1"},k=i("a",{class:"header-anchor",href:"#答案二-更新与读取操作进行异步串行化","aria-hidden":"true"},"#",-1),y={href:"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=%E7%AD%94%E6%A1%88%E4%BA%8C%EF%BC%9A-%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E5%8C%96",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=%E7%AD%94%E6%A1%88%E4%BA%8C%EF%BC%9A-%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E5%8C%96",target:"_blank",rel:"noopener noreferrer"},m=i("strong",null,"更新与读取操作进行异步串行化",-1),A=d('<h1 id="缓存问题" tabindex="-1"><a class="header-anchor" href="#缓存问题" aria-hidden="true">#</a> 缓存问题</h1><ul><li><p>怎么提高缓存命中率</p><ul><li>提前加载数据到缓存</li><li>提高缓存空间</li><li>提升缓存的更新频率</li></ul></li><li><p>缓存击穿、缓存穿透、缓存雪崩、缓存预热、缓存降级</p><ul><li>缓存击穿：key过期失效，然后大量请求对其发起请求，没法读到缓存而去读数据库 <ul><li>解决方案： <ul><li>业务允许的话，热数据永不过期</li><li>缓存失效后，通过锁或者队列来控制读写缓存的线程数量，此时系统吞吐量会下降</li></ul></li></ul></li><li>缓存穿透：缓存、数据库中都不存在，导致每次请求都要去访问数据库 <ul><li>解决方案： <ul><li>对参数做校验，不可能存在的key直接错误提示</li><li>把无用的key也存到缓存中，但如果每次访问的无用key都是随机的也没有意义</li><li>布隆过滤器：判定key不存在，那么就一定不存在。判定key存在，大概率是存在的，因为有误判的情况。每次查缓存的时候，先去查布隆过滤器，没有就直接返回</li></ul></li></ul></li><li>缓存雪崩：突发大规模的key失效，大量请求访问数据库 <ul><li>解决方案： <ul><li>均匀过期：给key设置不同的过期时间，使其尽量均匀</li><li>业务允许的话，热数据永不过期</li><li>分级缓存：一级没有访问二级，每级缓存访问失效时间不同</li><li>控制线程访问数量： <ul><li>互斥锁：对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁</li><li>熔断机制，限流降级。</li></ul></li><li>用集群或者主从+哨兵，开启日志，保证redis的高可用。</li></ul></li></ul></li><li>缓存预热：系统上线后，先将数据加载到缓存。 <ul><li>方案： <ul><li>数据量不大，重启后加载缓存</li><li>数据量大，优先加载热数据，设置定时脚本，进行缓存刷新</li></ul></li></ul></li><li>缓存降级：缓存失效或者服务挂掉，返回默认数据</li></ul></li><li><p>说一说你对布隆过滤器的理解</p><ul><li>布隆过滤器可以用很低的代价，估算出数据是否真实存在。例如：给用户推荐新闻时，要去掉重复的新闻，就可以利用布隆过滤器，判断该新闻是否已经推荐过。</li><li>布隆过滤器的核心包括两部分： <ul><li>一个大型的位数组；</li><li>若干个不一样的哈希函数，每个哈希函数都能将哈希值算的比较均匀。</li></ul></li><li>布隆过滤器的工作原理： <ul><li>添加key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置，并将位数组中这个位置的值设置为1。</li><li>询问key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值： <ul><li>如果这几个位置中，有一个位置的值是0，就说明这个布隆过滤器中，不存在这个key。</li><li>如果这几个位置中，所有位置的值都是1，就说明这个布隆过滤器中，极有可能存在这个key。之所以不是百分之百确定，是因为也可能是其他的key运算导致该位置为1。</li></ul></li></ul></li></ul></li></ul><h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h1><ul><li><p>Redis事务</p><ul><li>可以把多个命令一起执行，具有ACID原则，要么一起成功，要么一起失败。</li></ul></li><li><p>Reids事务支持隔离性吗</p><ul><li>支持，因为是单线程，所以能够保证不会对事务进行中断。</li></ul></li><li><p>Redis事务为什么不支持事务回滚</p><ul><li>Redis错误只会是语法错误导致的，这种错误应该在代码层就要解决的，因此不需要回滚机制。</li></ul></li><li><p>Redis事务的三个阶段</p><ul><li>MULTI：开启事务</li><li>输入多个命令操作</li><li>EXEC：事务执行</li></ul></li></ul><h1 id="pipeline" tabindex="-1"><a class="header-anchor" href="#pipeline" aria-hidden="true">#</a> pipeline</h1><ul><li>什么是redis的pipeline <ul><li>Redis的pipeline操作是一种优化技术，可以将多个Redis操作打包成一次批量操作，从而减少网络请求次数。</li><li>使用pipeline操作并不会改变Redis操作的语义，每个操作的执行顺序和结果都与直接执行该操作相同。</li></ul></li></ul><h1 id="主从、哨兵、集群" tabindex="-1"><a class="header-anchor" href="#主从、哨兵、集群" aria-hidden="true">#</a> 主从、哨兵、集群</h1>',7),E={href:"https://blog.csdn.net/qq_38658567/article/details/106840141",target:"_blank",rel:"noopener noreferrer"},b=d('<ul><li><p>Redis几种使用方式</p><ul><li>单机：</li><li>主从模式：读写分离，master挂掉需要手动选择新master，可用性不高，基本不用</li><li>哨兵模式（Redis Sentinel）：读写分离，高可用master挂掉会自动选举新的master，每个节点的数据是一样的，浪费内存空间</li><li>Redis Cluster：负载均衡，分布式存储，适用于海量数据。所有master的容量就是Redis Cluster 可缓存的容量</li></ul></li><li><p>Redis是如何实现高可用的</p><ul><li>数据持久化</li><li>主从数据同步</li><li>Redis哨兵模式</li><li>Redis 集群</li></ul></li><li><p>哨兵模式</p><figure><img src="https://secure2.wostatic.cn/static/mYikXfQA9LVe5WHHP8aJPR/image.png?auth_key=null" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>sentinel，中文是哨兵。哨兵是 redis 集群中非常重要的一个组件，主要功能： <ul><li>集群监控：负责监控节点是否正常工作。</li><li>消息通知：如果某个节点有故障，会把通知管理员。</li><li>故障转移：如果 master 节点挂掉了，会选举新的master节点</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul></li><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。也就是CAP理论的AP.</li></ul></li><li><p>集群模式/Redis Cluster</p><ul><li>简介 <ul><li>Redis Cluster是一种服务端Sharding技术， 3.0版本开始正式提供</li><li>Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽</li><li>将请求发送到任意节点，接收到请求的节点会将请求转发到正确的节点上执行</li></ul></li><li>方案说明： <ul><li>通过哈希的方式，将数据进行分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li><li>同一分片多个节点间的数据不保持一致性</li><li>读取数据时，当客户端操作的key没有分配在该节点上时， redis会返回转向指令，指向正确的节点</li></ul></li><li>在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个是 16379</li><li>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西， cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。</li><li>cluster bus 用了另外一种二进制的协议， gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</li><li>优点： <ul><li>无中心架构，支持动态扩容，对业务透明-</li><li>具备Sentinel的监控和自动故障转移(Failover)能力</li><li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li><li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li></ul></li><li>缺点： <ul><li>运维也很复杂，数据迁移需要人工干预</li><li>只能使用0号数据库</li><li>不支持批量操作(pipeline管道操作)</li><li>分布式逻辑和存储模块耦合等</li></ul></li></ul></li><li><p>Redis集群</p><ul><li>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。</li><li>所以在 Redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</li><li>优点 <ul><li>无中心架构；</li><li>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li><li>可扩展性：可线性扩展到1000多个节点，节点可动态添加或删除；</li><li>高可用性：部分节点不可用时，集群仍可用。通过增加Slave做数据副本，能够实现故障自动转移，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升；</li><li>降低运维成本，提高系统的扩展性和可用性。</li></ul></li></ul></li><li><p>Redis 集群为什么需要三个主节点</p><ul><li>这跟Redis主节点选举机制有关，如果Redis一个主节点挂了，那么Redis要求至少有超过一半的主节点选举到同一个从节点，才算选举成功。</li><li>如果只有两个主节点，一个挂了那么只剩下一个主节点，不满足选举条件。（1/2 没法大于一半，只能等于 ）</li><li>Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</li><li>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</li></ul></li><li><p>基于客户端分配</p><ul><li>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。</li><li>其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。</li><li>Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool</li><li>优点 <ul><li>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</li></ul></li><li>缺点 <ul><li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。</li><li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</li></ul></li></ul></li><li><p>基于代理服务器分片</p><figure><img src="https://secure2.wostatic.cn/static/bGdEATGZXZVvn8vjBtFuWm/image.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端</li><li>特征 <ul><li>透明接入，业务程序不用关心后端Redis实例，切换成本低</li><li>Proxy 的逻辑和存储的逻辑是隔离的</li><li>代理层多了一次转发，性能有所损耗</li></ul></li></ul></li><li><p>说说Redis哈希槽的概念？</p><ul><li>Redis集群没有使用一致性hash,而是引入了哈希槽的概念， Redis集群有16384个哈希槽，每个key通过CRC16校验后对1 6384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</li></ul></li><li><p>Redis集群会有写操作丢失吗？为什么？</p><ul><li>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</li></ul></li><li><p>Redis集群最大节点个数是多少？</p><ul><li>16384</li></ul></li><li><p>Redis集群如何选择数据库？</p><ul><li>Redis集群目前无法做数据库选择，默认在0数据库。</li></ul></li><li><p>为什么要主从架构</p><ul><li>为了系统高可用</li><li>一主多从，主负责写，从负责读，支撑读高并发。</li></ul></li></ul><h1 id="常用工具" tabindex="-1"><a class="header-anchor" href="#常用工具" aria-hidden="true">#</a> 常用工具</h1><ul><li><p>Redis支持的Java客户端都有哪些？官方推荐用哪个？</p><ul><li>Redisson、 Jedis、 lettuce等等，官方推荐使用Redisson</li></ul></li><li><p>Jedis与Redisson对比有什么优缺点？</p><ul><li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</li><li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</li></ul></li></ul><h1 id="数据结构的底层细节" tabindex="-1"><a class="header-anchor" href="#数据结构的底层细节" aria-hidden="true">#</a> 数据结构的底层细节</h1><ul><li><p>hash类型底层的数据结构</p><ul><li>哈希对象有两种编码方案 <ul><li>ziplist编码，ziplist编码底层采用压缩列表，需要满足以下两个条件 <ul><li>哈希对象保存的键值对数量小于512个；</li><li>哈希对象保存的所有键值对中的键和值，其字符串长度都小于64字节。</li></ul></li><li>hashtable编码，不满足以上两个条件的，用hashtable编码</li><li>hashtable编码采用字典作为底层实现。</li></ul></li></ul></li><li><p>跳跃表</p><figure><img src="https://secure2.wostatic.cn/static/qepwHYdZ9LxBLATa7XW2z1/image.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>跳跃表的查找复杂度为平均O(logN)，效率堪比红黑树，却远比红黑树实现简单。跳跃表是在链表的基础上，通过增加索引来提高查找效率的。</p></li><li><p>跳跃表是从有序链表中选取部分节点，组成一个新链表，并以此作为原始链表的一级索引。再从一级索引中选取部分节点，组成一个新链表，并以此作为原始链表的二级索引。以此类推，可以有多级索引</p></li><li><p>跳跃表在查找时，优先从高层开始查找，若next节点值大于目标值或指向NULL，则从当前节点下降一层继续向后查找，这样便可以提高查找的效率了。</p></li><li><p>跳跃表的实现主要涉及2个结构体：zskiplist、zskiplistNode</p></li></ul><figure><img src="https://secure2.wostatic.cn/static/4TNNhs6Cv9hAUAsbLC5EqM/image.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其中，蓝色的表格代表zskiplist，红色的表格代表zskiplistNode。zskiplist有指向头尾节点的指针，以及列表的长度，列表中最高的层级。zskiplistNode的头节点是空的，它不存储任何真实的数据，它拥有最高的层级，但这个层级不记录在zskiplist之内。</p><h1 id="redis-使用场景" tabindex="-1"><a class="header-anchor" href="#redis-使用场景" aria-hidden="true">#</a> Redis 使用场景</h1><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><ul><li>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？ <ul><li>keys命令：时间复杂度O(n),数据量太大会给阻塞Redis，生产环境决定不允许使用</li><li>scan命令：不会阻塞线程，但可能有重复key，需要客户端去重，以游标方式，速度慢</li></ul></li><li>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？ <ul><li>最后给过期时间后面加个随机时间，让过期时间更分散</li></ul></li></ul><h2 id="redis如何实现消息队列" tabindex="-1"><a class="header-anchor" href="#redis如何实现消息队列" aria-hidden="true">#</a> Redis如何实现消息队列</h2><ul><li>list 可以作为队列，rpush生产数据，lpop消费数据。</li><li>没消息的时候怎么操作： <ul><li>lpop没消息的时候要适当sleep再试</li><li>list 还有个指令叫blpop，没消息时候会阻塞直到有消息</li></ul></li><li>能不能生产一次消费多次： <ul><li>使用pub/sub主题订阅，可以实现1:N</li></ul></li></ul><h2 id="redis-实现分布式锁" tabindex="-1"><a class="header-anchor" href="#redis-实现分布式锁" aria-hidden="true">#</a> Redis 实现分布式锁</h2>',13),v={href:"https://www.nowcoder.com/issue/tutorial?tutorialId=94&uuid=08fe8b8fe674475d9f8cece289d63790",target:"_blank",rel:"noopener noreferrer"},B=d(`<ul><li>Redis 实现的分布式锁 <ul><li>加锁： <ul><li>第一版： <ul><li>setnx key value</li><li>这种方式的缺点是容易产生死锁，因为客户端有可能忘记解锁，或者解锁失败。</li></ul></li><li>第二版： <ul><li>setnx key value</li><li>expire key seconds</li><li>给锁增加了过期时间，避免出现死锁。但这两个命令不是原子的，第二步可能会失败，依然无法避免死锁问题。</li></ul></li><li>第三版 <ul><li>将加锁、过期命令编排到一起</li><li>set key value nx ex seconds</li></ul></li></ul></li><li>解锁： <ul><li>del key</li></ul></li><li>问题：进程A在任务没有执行完毕时，锁已经到期被释放了。等进程A的任务执行结束后，它依然会尝试释放锁，因为它的代码逻辑就是任务结束后释放锁。但是，它的锁早已自动释放过了，它此时释放的可能是其他线程的锁。</li><li>想要解决这个问题，我们需要解决两件事情： <ul><li>在加锁时就要给锁设置一个标识，进程要记住这个标识。当进程解锁的时候，要进行判断，只有是自己持有的锁才能释放。可以为key赋一个随机值，来充当进程的标识。</li><li>解锁时要先判断、再释放，这两步需要保证原子性，否则第二步失败的话，就会出现死锁。而获取和删除命令不是原子的，这就需要采用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的。</li></ul></li><li>按照以上思路，优化后的命令如下：</li></ul></li></ul><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>// 加锁 
set key random-value nx ex seconds   
// 解锁 

if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then     
return redis.call(&quot;del&quot;,KEYS[1]) else     return 0 end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>基于RedLock算法的分布式锁：</p><ul><li>上述分布式锁的实现方案，是建立在单个主节点之上的。如果进程A在主节点上加锁成功，然后这个主节点宕机了，然后从节点将会晋升为主节点。若此时进程B在新的主节点上加锁成功，之后原主节点重启，成为了从节点，系统中将同时出现两把锁，这是违背锁的唯一性原则的。</li><li>Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点，它的基本逻辑是： <ul><li>这些节点相互独立，不存在主从复制或者集群协调机制；</li><li>加锁：以相同的KEY向N个实例加锁，只要超过一半节点成功，则认定加锁成功；</li><li>解锁：向所有的实例发送DEL命令，进行解锁；</li></ul></li><li>RedLock算法的示意图如下，我们可以自己实现该算法，也可以直接使用Redisson框架。</li></ul><figure><img src="https://secure2.wostatic.cn/static/rqhFWidhjFFu2hn2K9LDum/image.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul>`,3),x={href:"http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/",target:"_blank",rel:"noopener noreferrer"},_=d('<ul><li>简单的实现： <ul><li>加锁：setnx key value</li><li>解锁：del key</li><li>问题：带来死锁</li><li>解决办法：添加过期时间</li></ul></li><li>过期时间的实现 <ul><li>加锁：setnx key value</li><li>设置过期时间：expire key 秒数</li><li>解锁：del key</li><li>问题：不是原子性</li><li>解决办法：redis 支持加锁和设置过期时间编排成一条</li></ul></li><li>加锁和设置过期时间编排成一条原子性命令： <ul><li>加锁并设置过期时间：set key value ex 秒数 nx</li><li>解锁：del key</li><li>问题：del key 可能删除的是别人的锁，因为我的锁可能过期自己释放了</li><li>解决办法：为value 设置一个uuid作为唯一标识，解锁时候判断是不是自己的uuid，是再删除</li></ul></li><li>为value设置一个uuid <ul><li>解锁的过程：先获取key的value值是自己的uuid，如果是，再删除掉</li><li>问题：判断是不是自己的uuid和删除key的命令不是原子性的</li><li>解决：引入lua脚本，因为lua脚本是原子性的</li><li>问题：过期时间还是不好评估</li></ul></li><li>Redisson框架 <ul><li>引入Redisson 框架，内部有一个看门狗机制，看门狗机制就是一个守护线程，它会对锁自动续期来避免锁的过期</li></ul></li></ul><h2 id="如何利用redis实现分布式session" tabindex="-1"><a class="header-anchor" href="#如何利用redis实现分布式session" aria-hidden="true">#</a> 如何利用Redis实现分布式Session？</h2><ul><li><p>为什么需要</p><ul><li>在web开发中，我们会把用户的登录信息存储在session里。而session是依赖于cookie的，即服务器创建session时会给它分配一个唯一的ID，并且在响应时创建一个cookie用于存储这个SESSIONID。</li><li>当客户端收到这个cookie之后，就会自动保存这个SESSIONID，并且在下次访问时自动携带这个SESSIONID，届时服务器就可以通过这个SESSIONID得到与之对应的session，从而识别用户的身份。</li><li>现在的互联网应用，基本都是采用分布式部署方式，即将应用程序部署在多台服务器上，并通过nginx做统一的请求分发。而服务器与服务器之间是隔离的，它们的session是不共享的，这就存在session同步的问题了。</li><li>如果客户端第一次访问服务器，请求被分发到了服务器A上，则服务器A会为该客户端创建session。如果客户端再次访问服务器，请求被分发到服务器B上，则由于服务器B中没有这个session，所以用户的身份无法得到验证，从而产生了不一致的问题。</li></ul></li><li><p>怎么做</p><ul><li>我们使用session保存用户的身份信息，本质上是要做两件事情。第一是保存用户的身份信息，第二是验证用户的身份信息。如果利用其它手段实现这两个目标，那么就可以不用session，或者说我们使用的是广义上的session了。 <ul><li>第一：需要一个创建令牌的程序，就是在用户初次访问服务器时，给它创建一个唯一的身份标识，并且使用cookie封装这个标识再发送给客户端。在返回令牌之前，我们需要将它存储起来，以便于后续的验证。而这个令牌是不能保存在服务器本地的，存到Redis是一个理想的场所。</li><li>第二：需要一个验证令牌的程序，就是在用户再次访问服务器时，我们获取到了它之前的身份标识，那么我们就要验证一下这个标识是否存在了。验证的过程很简单，我们从Redis中尝试获取一下就可以知道结果。</li></ul></li></ul></li><li><p>如果并发量超过30万，怎么设计Redis架构？</p><ul><li>Redis Cluster是Redis的分布式解决方案,当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。</li><li>Redis集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到0-16383整数槽内，计算公式为slot=CRC16(key)&amp;16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点： <ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩的难度；</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；</li><li>支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景。</li></ul></li><li>Redis集群中数据的分片逻辑如下图：</li></ul><figure><img src="https://secure2.wostatic.cn/static/tgB6hjdu3bG228jz6XkNRs/image.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><h1 id="其他知识点" tabindex="-1"><a class="header-anchor" href="#其他知识点" aria-hidden="true">#</a> 其他知识点</h1><ul><li>Redis安全配置（来自sage） <ol><li>修改 Redis 默认密码: Redis 默认没有密码，因此第一步是设置一个强密码。可以在 Redis 配置文件中设置密码，使用 <code>requirepass</code> 参数即可。例如：<code>requirepass mypassword</code>。另外，也可以在启动 Redis 服务器时通过命令行参数设置密码，例如：<code>redis-server --requirepass mypassword</code>。</li><li>禁用危险命令: Redis 中有一些危险的命令（如 FLUSHALL、FLUSHDB、CONFIG、SHUTDOWN 等），这些命令可能会导致数据丢失或服务器崩溃。为了保护 Redis 服务器的安全，可以使用 Redis 配置文件中的 <code>rename-command</code> 参数来修改或禁用这些命令。例如，可以将 FLUSHALL 命令重命名为随机字符串，从而禁用该命令：“<code>rename-command FLUSHALL randomstring</code>”。</li><li>禁用危险命令: Redis 中有一些危险的命令（如 FLUSHALL、FLUSHDB、CONFIG、SHUTDOWN 等），这些命令可能会导致数据丢失或服务器崩溃。为了保护 Redis 服务器的安全，可以使用 Redis 配置文件中的 <code>rename-command</code> 参数来修改或禁用这些命令。例如，可以将 FLUSHALL 命令重命名为随机字符串，从而禁用该命令：“<code>rename-command FLUSHALL randomstring</code>”。</li><li>配置访问控制列表（ACL）: Redis 6 之后引入了 ACL 功能，可以通过配置 ACL 来限制访问 Redis 的用户和命令。可以在 Redis 配置文件中使用 <code>user</code> 和 <code>aclfile</code> 参数配置 ACL。例如，可以在 <code>aclfile</code> 文件中添加用户和相关权限：“<code>user myuser on +@all -@dangerous</code>”，其中 <code>+@all</code> 表示允许访问所有命令，<code>-@dangerous</code> 表示禁止访问危险命令。</li><li>启用持久化: Redis 支持将数据持久化到磁盘，以避免数据丢失。可以通过 Redis 配置文件中的 <code>save</code> 参数或者使用 AOF（Append Only File）功能来启用持久化。建议至少开启 AOF 功能，并设置适当的 AOF 写入频率和文件大小限制，以确保数据及时写入磁盘并避免 AOF 文件过大导致性能问题。</li><li>限制最大连接数: Redis 默认没有限制最大连接数，这可能会导致服务器资源被耗尽。可以在 Redis 配置文件中使用 maxclients 参数设置最大连接数。建议根据服务器容量和实际需求设置合理的最大连接数。</li><li>使用 TLS/SSL 加密传输: Redis 默认不支持加密传输，因此敏感数据可能会被窃取。可以使用 TLS/SSL 加密传输 Redis 数据，以增加数据传输的安全性。可以使用 stunnel、stunnel4、haproxy 等工具来实现 TLS/SSL 加密。</li></ol></li></ul><p>修改 Redis 默认密码: Redis 默认没有密码，因此第一步是设置一个强密码。可以在 Redis 配置文件中设置密码，使用 requirepass 参数即可。例如：requirepass mypassword。另外，也可以在启动 Redis 服务器时通过命令行参数设置密码，例如：redis-server --requirepass mypassword。</p>',6);function S(L,C){const e=u("ExternalLinkIcon");return r(),n("div",null,[o,i("h3",c,[p,l(),i("a",h,[l("答案一：延时双删"),s(e)])]),R,i("h3",g,[k,l(),i("a",y,[l("答案二： "),s(e)]),i("a",f,[m,s(e)])]),A,i("p",null,[i("a",E,[l("redis — 集群模式与原理介绍（一）_RachelHwang的博客-CSDN博客_redis 集群实现方式"),s(e)])]),b,i("blockquote",null,[i("p",null,[i("a",v,[l("https://www.nowcoder.com/issue/tutorial?tutorialId=94&uuid=08fe8b8fe674475d9f8cece289d63790"),s(e)])])]),B,i("p",null,[i("a",x,[l("深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了！ | Kaito's Blog (kaito-kidd.com)"),s(e)])]),_])}const H=a(t,[["render",S],["__file","Redis.html.vue"]]);export{H as default};
