const l=JSON.parse('{"key":"v-8558a028","path":"/java/JVM.html","title":"JVM","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-08-08T00:00:00.000Z","category":["java"],"tag":["jvm","垃圾回收","内存结构"],"description":"JVM 对象问题 对象创建的主要流程 虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。 类加载通过后，接下来分配内存。 若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存； 指针碰撞：如果Java堆的内存是规整，指针指示器向空闲的内存移动一段与对象大小相等的距离 如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。 虚拟机维护一个列表来记录可用的内存，在分配的时候可以从列表中查询到足够大的内存分配给对象，接着更新列表记录。 划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理， 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。 然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行方法。 对象分配内存的并发安全问题 对象的创建是一个非常频繁的行为，可能会出现 正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存 的情况。解决这个问题有两种方案： 对分配内存空间的动作进行同步处理（采用&nbsp;CAS&nbsp;+&nbsp;失败重试来保障更新操作的原子性）； 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的&nbsp;TLAB&nbsp;上分配。只有&nbsp;TLAB&nbsp;用完并分配新的&nbsp;TLAB&nbsp;时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。 对象的访问定位 Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。 指针：&nbsp;指向对象，代表一个对象在内存中的起始地址。 句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。 直接指针 如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。 优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非 常频繁，因此这类开销积少成多后也是非常可观的执行成本。 HotSpot&nbsp;中采用 的就是这种方式。 句柄 Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息 优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。 什么是指针碰撞 一般情况下， JVM的对象都放在堆内存中（发生逃逸分析除外）。当JVM为新对象分配内存时，如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是 指针碰撞。 什么是空闲列表 如果Java堆内存中的内存并不是规整的，不可以进行指针碰撞 虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。 什么是TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB 对象栈分配 首先要讲一下方法逃逸：当JVM发现，当前对象只会在某个方法块里使用，那么我们就说它逃逸分析了 对于满足逃逸分析的对象，那么JVM对于该对象分配内存会分配到栈上，减少堆GC的压力 逃逸分析 https://bbs.huaweicloud.com/blogs/274124 https://zhuanlan.zhihu.com/p/59215831 有讲到方法逃逸和线程逃逸 当JVM发现，当前对象只会在某个方法块里使用，那么我们就说它逃逸分析了 Java的逃逸分析只发在JIT的即时编译中 -XX:+DoEscapeAnalysis表示开启逃逸分析，JDK8是默认开启的 科普：JDK 6 Update 23默认开启，在某些版本（如JDK 6 Update 18）中还曾完全禁止这项优化 对象具体包含哪些内容 对象头 对象运行所需要的数据，称为Mark Work，具体内容包含：对象hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。 存储类型指针，通过这个指针知道对象是属于哪个类的。 实例数据 对齐填充","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/java/JVM.html"}],["meta",{"property":"og:site_name","content":"BlueSky的八股文"}],["meta",{"property":"og:title","content":"JVM"}],["meta",{"property":"og:description","content":"JVM 对象问题 对象创建的主要流程 虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。 类加载通过后，接下来分配内存。 若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存； 指针碰撞：如果Java堆的内存是规整，指针指示器向空闲的内存移动一段与对象大小相等的距离 如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。 虚拟机维护一个列表来记录可用的内存，在分配的时候可以从列表中查询到足够大的内存分配给对象，接着更新列表记录。 划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理， 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。 然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行方法。 对象分配内存的并发安全问题 对象的创建是一个非常频繁的行为，可能会出现 正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存 的情况。解决这个问题有两种方案： 对分配内存空间的动作进行同步处理（采用&nbsp;CAS&nbsp;+&nbsp;失败重试来保障更新操作的原子性）； 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的&nbsp;TLAB&nbsp;上分配。只有&nbsp;TLAB&nbsp;用完并分配新的&nbsp;TLAB&nbsp;时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。 对象的访问定位 Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。 指针：&nbsp;指向对象，代表一个对象在内存中的起始地址。 句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。 直接指针 如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。 优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非 常频繁，因此这类开销积少成多后也是非常可观的执行成本。 HotSpot&nbsp;中采用 的就是这种方式。 句柄 Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息 优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。 什么是指针碰撞 一般情况下， JVM的对象都放在堆内存中（发生逃逸分析除外）。当JVM为新对象分配内存时，如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是 指针碰撞。 什么是空闲列表 如果Java堆内存中的内存并不是规整的，不可以进行指针碰撞 虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。 什么是TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB 对象栈分配 首先要讲一下方法逃逸：当JVM发现，当前对象只会在某个方法块里使用，那么我们就说它逃逸分析了 对于满足逃逸分析的对象，那么JVM对于该对象分配内存会分配到栈上，减少堆GC的压力 逃逸分析 https://bbs.huaweicloud.com/blogs/274124 https://zhuanlan.zhihu.com/p/59215831 有讲到方法逃逸和线程逃逸 当JVM发现，当前对象只会在某个方法块里使用，那么我们就说它逃逸分析了 Java的逃逸分析只发在JIT的即时编译中 -XX:+DoEscapeAnalysis表示开启逃逸分析，JDK8是默认开启的 科普：JDK 6 Update 23默认开启，在某些版本（如JDK 6 Update 18）中还曾完全禁止这项优化 对象具体包含哪些内容 对象头 对象运行所需要的数据，称为Mark Work，具体内容包含：对象hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。 存储类型指针，通过这个指针知道对象是属于哪个类的。 实例数据 对齐填充"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"blueSky"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:tag","content":"垃圾回收"}],["meta",{"property":"article:tag","content":"内存结构"}],["meta",{"property":"article:published_time","content":"2023-08-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"blueSky\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"对象问题","slug":"对象问题","link":"#对象问题","children":[]},{"level":2,"title":"内存结构","slug":"内存结构","link":"#内存结构","children":[]},{"level":2,"title":"方法区","slug":"方法区","link":"#方法区","children":[]},{"level":2,"title":"类加载相关","slug":"类加载相关","link":"#类加载相关","children":[]},{"level":2,"title":"GC相关","slug":"gc相关","link":"#gc相关","children":[]},{"level":2,"title":"垃圾收集器","slug":"垃圾收集器","link":"#垃圾收集器","children":[]},{"level":2,"title":"性能调优","slug":"性能调优","link":"#性能调优","children":[]},{"level":2,"title":"生产问题","slug":"生产问题","link":"#生产问题","children":[]},{"level":2,"title":"JIT问题","slug":"jit问题","link":"#jit问题","children":[]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[]}],"git":{},"readingTime":{"minutes":28.46,"words":8537},"filePathRelative":"java/JVM.md","localizedDate":"August 8, 2023","excerpt":"<h1> JVM</h1>\\n<h2> 对象问题</h2>\\n<ul>\\n<li>\\n<p>对象创建的主要流程</p>\\n<ul>\\n<li>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。</li>\\n<li>类加载通过后，接下来分配内存。\\n<ul>\\n<li>若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；\\n<ul>\\n<li>指针碰撞：如果Java堆的内存是规整，指针指示器向空闲的内存移动一段与对象大小相等的距离</li>\\n</ul>\\n</li>\\n<li>如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。\\n<ul>\\n<li>虚拟机维护一个列表来记录可用的内存，在分配的时候可以从列表中查询到足够大的内存分配给对象，接着更新列表记录。</li>\\n</ul>\\n</li>\\n<li>划分内存时还需要考虑一个问题-并发，也有两种方式:\\n<ul>\\n<li>CAS同步处理，</li>\\n<li>本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行方法。</li>\\n</ul>\\n</li>\\n<li>\\n<p>对象分配内存的并发安全问题</p>\\n<ul>\\n<li>对象的创建是一个非常频繁的行为，可能会出现 正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存 的情况。解决这个问题有两种方案：\\n<ul>\\n<li>对分配内存空间的动作进行同步处理（采用&nbsp;CAS&nbsp;+&nbsp;失败重试来保障更新操作的原子性）；</li>\\n<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的&nbsp;TLAB&nbsp;上分配。只有&nbsp;TLAB&nbsp;用完并分配新的&nbsp;TLAB&nbsp;时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>对象的访问定位</p>\\n<ul>\\n<li>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。\\n<ul>\\n<li>指针：&nbsp;指向对象，代表一个对象在内存中的起始地址。</li>\\n<li>句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>直接指针</p>\\n<figure><img src=\\"https://secure2.wostatic.cn/static/bPBBGnBPVPYUSgFBQfKLUd/image.png?auth_key=1691509572-nrDjkFUdrzUUKxERcbHjWd-0-081cd3ea8128783f5eff8f0f752f0780\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<ul>\\n<li>如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。</li>\\n<li>优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非<br>\\n常频繁，因此这类开销积少成多后也是非常可观的执行成本。 HotSpot&nbsp;中采用<br>\\n的就是这种方式。</li>\\n</ul>\\n</li>\\n<li>\\n<p>句柄</p>\\n<figure><img src=\\"https://secure2.wostatic.cn/static/5uJhnJtkXH3pVbUX9oMVnn/image.png?auth_key=1691509572-qeCFTpbiyVEwk1cUuqBJFT-0-10114e15250cded8950df9c621432c7c\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<ul>\\n<li>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息</li>\\n<li>优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</li>\\n</ul>\\n</li>\\n<li>\\n<p>什么是指针碰撞</p>\\n<ul>\\n<li>一般情况下， JVM的对象都放在堆内存中（发生逃逸分析除外）。当JVM为新对象分配内存时，如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是 指针碰撞。</li>\\n</ul>\\n</li>\\n<li>\\n<p>什么是空闲列表</p>\\n<ul>\\n<li>如果Java堆内存中的内存并不是规整的，不可以进行指针碰撞</li>\\n<li>虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</li>\\n</ul>\\n</li>\\n<li>\\n<p>什么是TLAB</p>\\n<ul>\\n<li>把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB</li>\\n</ul>\\n</li>\\n<li>\\n<p>对象栈分配</p>\\n<ul>\\n<li>首先要讲一下方法逃逸：当JVM发现，当前对象只会在某个方法块里使用，那么我们就说它逃逸分析了</li>\\n<li>对于满足逃逸分析的对象，那么JVM对于该对象分配内存会分配到栈上，减少堆GC的压力</li>\\n</ul>\\n</li>\\n<li>\\n<p>逃逸分析</p>\\n<ul>\\n<li><a href=\\"https://bbs.huaweicloud.com/blogs/274124\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://bbs.huaweicloud.com/blogs/274124</a></li>\\n<li><a href=\\"https://zhuanlan.zhihu.com/p/59215831\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://zhuanlan.zhihu.com/p/59215831</a>   有讲到方法逃逸和线程逃逸</li>\\n<li>当JVM发现，当前对象只会在某个方法块里使用，那么我们就说它逃逸分析了</li>\\n<li>Java的逃逸分析只发在JIT的即时编译中</li>\\n<li>-XX:+DoEscapeAnalysis表示开启逃逸分析，JDK8是默认开启的</li>\\n<li>科普：JDK 6 Update 23默认开启，在某些版本（如JDK 6 Update 18）中还曾完全禁止这项优化</li>\\n</ul>\\n</li>\\n<li>\\n<p>对象具体包含哪些内容</p>\\n<ul>\\n<li>对象头\\n<ul>\\n<li>对象运行所需要的数据，称为Mark Work，具体内容包含：对象hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。</li>\\n<li>存储类型指针，通过这个指针知道对象是属于哪个类的。</li>\\n</ul>\\n</li>\\n<li>实例数据</li>\\n<li>对齐填充</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{l as data};
