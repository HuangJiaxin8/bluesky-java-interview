const l=JSON.parse('{"key":"v-0e488841","path":"/java/MQ.html","title":"MQ","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-08-08T00:00:00.000Z","category":["java"],"tag":["jvm","垃圾回收","内存结构"],"description":"MQ MQ MQ 有哪几种工作模式 点对点模式（一对一） 发布订阅（一对多） 为什么使用消息队列 解耦、异步、削峰 解耦 A系统发送数据到BCD三个系统，通过接口调用发送。 如果E系统也要这个接口呢？如果D系统现在又不需要了呢？这时候A系统的负责人就会很崩溃。 引入了MQ之后，A系统只需要产生一个数据，发送到MQ里面去，哪个系统需要就去MQ消费。 异步 A系统接收一个任务，需要自己写在本库，还要写BCD三个库。写完之后再响应客户，这样是比较耗时的。 引入MQ之后，A系统只需要写在本库，然后把数据发送到MQ里面，就可以响应用户了。BCD在后台读取MQ的数据，然后写库。 削峰： 减少高峰期对服务器的压力。 MQ有什么优缺点 优点：解耦、异步、削峰 缺点： 系统可用性降低，引入MQ组件，万一MQ组件挂了怎么办呢 系统复杂性提高，多了个MQ组件，MQ组件产生的问题也要解决。比如，怎么保证消息没有重复消费？消息丢失怎么办？如何保证消息传递的顺序性？ 一致性问题：A系统写完数据，人都以为这个请求成功了。然后后台BCD三个系统，万一D写库失败了怎么办？这会导致数据不一致的问题。 说一下生产者，消费者模式 所谓生产者-消费者问题，实际上主要是包含了两类线程。一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库。 生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为。而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。 但是，这个共享数据区域中应该具备这样的线程间并发协作的功能： 使用 Object 的 wait/notify 的消息通知机制； 使用 Lock 的 Condition 的 await/signal 的消息通知机制； 使用 BlockingQueue 实现。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/java/MQ.html"}],["meta",{"property":"og:site_name","content":"BlueSky的八股文"}],["meta",{"property":"og:title","content":"MQ"}],["meta",{"property":"og:description","content":"MQ MQ MQ 有哪几种工作模式 点对点模式（一对一） 发布订阅（一对多） 为什么使用消息队列 解耦、异步、削峰 解耦 A系统发送数据到BCD三个系统，通过接口调用发送。 如果E系统也要这个接口呢？如果D系统现在又不需要了呢？这时候A系统的负责人就会很崩溃。 引入了MQ之后，A系统只需要产生一个数据，发送到MQ里面去，哪个系统需要就去MQ消费。 异步 A系统接收一个任务，需要自己写在本库，还要写BCD三个库。写完之后再响应客户，这样是比较耗时的。 引入MQ之后，A系统只需要写在本库，然后把数据发送到MQ里面，就可以响应用户了。BCD在后台读取MQ的数据，然后写库。 削峰： 减少高峰期对服务器的压力。 MQ有什么优缺点 优点：解耦、异步、削峰 缺点： 系统可用性降低，引入MQ组件，万一MQ组件挂了怎么办呢 系统复杂性提高，多了个MQ组件，MQ组件产生的问题也要解决。比如，怎么保证消息没有重复消费？消息丢失怎么办？如何保证消息传递的顺序性？ 一致性问题：A系统写完数据，人都以为这个请求成功了。然后后台BCD三个系统，万一D写库失败了怎么办？这会导致数据不一致的问题。 说一下生产者，消费者模式 所谓生产者-消费者问题，实际上主要是包含了两类线程。一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库。 生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为。而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。 但是，这个共享数据区域中应该具备这样的线程间并发协作的功能： 使用 Object 的 wait/notify 的消息通知机制； 使用 Lock 的 Condition 的 await/signal 的消息通知机制； 使用 BlockingQueue 实现。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"blueSky"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:tag","content":"垃圾回收"}],["meta",{"property":"article:tag","content":"内存结构"}],["meta",{"property":"article:published_time","content":"2023-08-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MQ\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"blueSky\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"MQ","slug":"mq-1","link":"#mq-1","children":[]},{"level":2,"title":"Kafka","slug":"kafka","link":"#kafka","children":[]},{"level":2,"title":"RabbitMQ","slug":"rabbitmq","link":"#rabbitmq","children":[]},{"level":2,"title":"RocketMQ","slug":"rocketmq","link":"#rocketmq","children":[]}],"git":{},"readingTime":{"minutes":16.82,"words":5045},"filePathRelative":"java/MQ.md","localizedDate":"August 8, 2023","excerpt":"<h1> MQ</h1>\\n<h2> MQ</h2>\\n<ul>\\n<li>\\n<p>MQ 有哪几种工作模式</p>\\n<ul>\\n<li>点对点模式（一对一）</li>\\n<li>发布订阅（一对多）</li>\\n</ul>\\n</li>\\n<li>\\n<p>为什么使用消息队列</p>\\n<ul>\\n<li>解耦、异步、削峰</li>\\n<li>解耦\\n<ul>\\n<li>A系统发送数据到BCD三个系统，通过接口调用发送。</li>\\n<li>如果E系统也要这个接口呢？如果D系统现在又不需要了呢？这时候A系统的负责人就会很崩溃。</li>\\n<li>引入了MQ之后，A系统只需要产生一个数据，发送到MQ里面去，哪个系统需要就去MQ消费。</li>\\n</ul>\\n</li>\\n<li>异步\\n<ul>\\n<li>A系统接收一个任务，需要自己写在本库，还要写BCD三个库。写完之后再响应客户，这样是比较耗时的。</li>\\n<li>引入MQ之后，A系统只需要写在本库，然后把数据发送到MQ里面，就可以响应用户了。BCD在后台读取MQ的数据，然后写库。</li>\\n</ul>\\n</li>\\n<li>削峰：\\n<ul>\\n<li>减少高峰期对服务器的压力。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>MQ有什么优缺点</p>\\n<ul>\\n<li>优点：解耦、异步、削峰</li>\\n<li>缺点：\\n<ul>\\n<li>系统可用性降低，引入MQ组件，万一MQ组件挂了怎么办呢</li>\\n<li>系统复杂性提高，多了个MQ组件，MQ组件产生的问题也要解决。比如，怎么保证消息没有重复消费？消息丢失怎么办？如何保证消息传递的顺序性？</li>\\n<li>一致性问题：A系统写完数据，人都以为这个请求成功了。然后后台BCD三个系统，万一D写库失败了怎么办？这会导致数据不一致的问题。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>说一下生产者，消费者模式</p>\\n<ul>\\n<li>所谓生产者-消费者问题，实际上主要是包含了两类线程。一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库。</li>\\n<li>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为。而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。</li>\\n<li>但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：\\n<ul>\\n<li>使用 Object 的 wait/notify 的消息通知机制；</li>\\n<li>使用 Lock 的 Condition 的 await/signal 的消息通知机制；</li>\\n<li>使用 BlockingQueue 实现。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{l as data};
