const n=JSON.parse(`{"key":"v-507bd3ab","path":"/java/MySQL.html","title":"MySQL","lang":"en-US","frontmatter":{"icon":"pen-to-square","date":"2023-08-08T00:00:00.000Z","category":["java"],"tag":["mysql","索引","sql优化"],"description":"MySQL 基础 1. 数据库的三范式是什么？ 第一范式：列不可拆分，即原子性 第二范式：行记录唯一，即唯一性 第三范式：不可派生，即如果两个列通过计算可以得到第三列，那么不需要设置第三列。 备注：第三范式已经过时，有时候为了效率多设置一个列，可以牺牲第三范式，达到空间换时间的目的 2. MySQL 支持哪些存储引擎? 说说常见的innodb和myisam吧，说说他们的区别 区别： innodb支持事务、主键、外键，myisam不支持 innodb支持行级锁和表级锁，而myisam只支持表级锁 myisam内部有存储表行数的变量，而innodb没有 3. 超键、候选键、主键、外键分别是什么？ 不背 4. SQL 约束有哪几种？ NotNull，unique，主键，外键，check 5. MySQL 中的 varchar 和 char 有什么区别？ char是定长的字符，比如我们申请了char(10),无论插入多长数据都占用10个字符、 varchar是可变长的字符，数字代表的是最大字符数，实际占用是实际长度+1，最后一个字符记录的是字符长度 速度上看，char&gt;varchar。 6. MySQL中 in 和 exists 区别 暂时不背 7. drop、delete与truncate的区别 delete是DML语言，所以支持事务，drop和truncate是DDL语言，语句不支持事务 drop是删除整张表，truncate删除全部数据，不删除表结构，而delete可以删除部分数据。 速度上看，drop&gt;truncate&gt;delete 8. 什么是存储过程？有哪些优缺点？ 预编译的SQL语句 但不推荐使用，不好维护和迁移 9. MySQL 执行查询的过程 客户端TCP链接到连接器，这个阶段会做身份校验和资源分配 查缓存 语法分析，检查SQL语句是否写错了，表和表数据是否存在，别名是否有歧义等 优化，是否使用了索引 执行器执行，把结果集查询出来然后保存到缓存 MySQL常用的函数有哪些 avg()平均数 sum()总数 max()最大 min()最小 abs() 绝对值 concat('a','b') replace(str,old,new) 查询语句不同元素执行先后顺序？ where group by having select distinct order by limit count 性能哪种更好 count(*) = count(1) &gt; count(主键) &gt; count （字段） count(1) : 如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引。 如果有二级索引，就遍历二级索引。 count(*) 其实等于 count(0)，也就是说，当你使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。 count(*) 执行过程跟 count(1) 执行过程基本一样的 count(主键) 如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引。 如果有二级索引，就遍历二级索引。 count(普通字段) 全表扫描，最慢 having和where 有什么区别 where是在结果集返回之前的过滤，having是在结果集返回之后的过滤。 having通常配合group by一起使用，用于分组后的过滤 where 不能使用聚合函数以及聚合函数的别名，having可以 select goods_category_id , avg(goods_price) as ag from sw_goods group by goods_category having ag &gt; 1000 select goods_category_id , avg(goods_price) as ag from sw_goods where ag&gt;1000 group by goods_category //报错！！因为from sw_goods 这张数据表里面没有ag这个字段 union 和 union all 有什么区别 union 对于重复的记录会去重，union all不会 union默认会按照字段的顺序排序，union all 不会 结论：UNION去重且排序，UNION ALL不去重不排序 left join ，right join，inner join的区别 left join 返回左表的所有记录和右边匹配到的记录 right join 返回右表的所有记录和左表匹配到的记录 inner join 返回左右两张表共同匹配的部分 TIMESTAMP 与 DATETIME 的区别 相同点： TIMESTAMP 列的显示格式与 DATETIME 列相同。格式为YYYY-MM-DD HH:MM:SS。 不同点： TIMESTAMP： 4个字节存储，时间范围：1970-01-01 08:00:01~2038-01-19 11:14:07 值以UTC格式保存，涉及时区转化，存储时对当前的时区进行转换，检索时再转换回当前的时区 DATETIME 8个字节存储，时间范围：1000-10-01 00:00:00~9999-12-31 23:59:59 实际格式存储，与时区无关","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/bluesky-java-interview/java/MySQL.html"}],["meta",{"property":"og:site_name","content":"BlueSky的八股文"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":"MySQL 基础 1. 数据库的三范式是什么？ 第一范式：列不可拆分，即原子性 第二范式：行记录唯一，即唯一性 第三范式：不可派生，即如果两个列通过计算可以得到第三列，那么不需要设置第三列。 备注：第三范式已经过时，有时候为了效率多设置一个列，可以牺牲第三范式，达到空间换时间的目的 2. MySQL 支持哪些存储引擎? 说说常见的innodb和myisam吧，说说他们的区别 区别： innodb支持事务、主键、外键，myisam不支持 innodb支持行级锁和表级锁，而myisam只支持表级锁 myisam内部有存储表行数的变量，而innodb没有 3. 超键、候选键、主键、外键分别是什么？ 不背 4. SQL 约束有哪几种？ NotNull，unique，主键，外键，check 5. MySQL 中的 varchar 和 char 有什么区别？ char是定长的字符，比如我们申请了char(10),无论插入多长数据都占用10个字符、 varchar是可变长的字符，数字代表的是最大字符数，实际占用是实际长度+1，最后一个字符记录的是字符长度 速度上看，char&gt;varchar。 6. MySQL中 in 和 exists 区别 暂时不背 7. drop、delete与truncate的区别 delete是DML语言，所以支持事务，drop和truncate是DDL语言，语句不支持事务 drop是删除整张表，truncate删除全部数据，不删除表结构，而delete可以删除部分数据。 速度上看，drop&gt;truncate&gt;delete 8. 什么是存储过程？有哪些优缺点？ 预编译的SQL语句 但不推荐使用，不好维护和迁移 9. MySQL 执行查询的过程 客户端TCP链接到连接器，这个阶段会做身份校验和资源分配 查缓存 语法分析，检查SQL语句是否写错了，表和表数据是否存在，别名是否有歧义等 优化，是否使用了索引 执行器执行，把结果集查询出来然后保存到缓存 MySQL常用的函数有哪些 avg()平均数 sum()总数 max()最大 min()最小 abs() 绝对值 concat('a','b') replace(str,old,new) 查询语句不同元素执行先后顺序？ where group by having select distinct order by limit count 性能哪种更好 count(*) = count(1) &gt; count(主键) &gt; count （字段） count(1) : 如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引。 如果有二级索引，就遍历二级索引。 count(*) 其实等于 count(0)，也就是说，当你使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。 count(*) 执行过程跟 count(1) 执行过程基本一样的 count(主键) 如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引。 如果有二级索引，就遍历二级索引。 count(普通字段) 全表扫描，最慢 having和where 有什么区别 where是在结果集返回之前的过滤，having是在结果集返回之后的过滤。 having通常配合group by一起使用，用于分组后的过滤 where 不能使用聚合函数以及聚合函数的别名，having可以 select goods_category_id , avg(goods_price) as ag from sw_goods group by goods_category having ag &gt; 1000 select goods_category_id , avg(goods_price) as ag from sw_goods where ag&gt;1000 group by goods_category //报错！！因为from sw_goods 这张数据表里面没有ag这个字段 union 和 union all 有什么区别 union 对于重复的记录会去重，union all不会 union默认会按照字段的顺序排序，union all 不会 结论：UNION去重且排序，UNION ALL不去重不排序 left join ，right join，inner join的区别 left join 返回左表的所有记录和右边匹配到的记录 right join 返回右表的所有记录和左表匹配到的记录 inner join 返回左右两张表共同匹配的部分 TIMESTAMP 与 DATETIME 的区别 相同点： TIMESTAMP 列的显示格式与 DATETIME 列相同。格式为YYYY-MM-DD HH:MM:SS。 不同点： TIMESTAMP： 4个字节存储，时间范围：1970-01-01 08:00:01~2038-01-19 11:14:07 值以UTC格式保存，涉及时区转化，存储时对当前的时区进行转换，检索时再转换回当前的时区 DATETIME 8个字节存储，时间范围：1000-10-01 00:00:00~9999-12-31 23:59:59 实际格式存储，与时区无关"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"blueSky"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:tag","content":"索引"}],["meta",{"property":"article:tag","content":"sql优化"}],["meta",{"property":"article:published_time","content":"2023-08-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"blueSky\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[]},{"level":2,"title":"索引","slug":"索引","link":"#索引","children":[]},{"level":2,"title":"数据库事务","slug":"数据库事务","link":"#数据库事务","children":[]},{"level":2,"title":"日志文件","slug":"日志文件","link":"#日志文件","children":[]},{"level":2,"title":"事务隔离级别","slug":"事务隔离级别","link":"#事务隔离级别","children":[]},{"level":2,"title":"锁","slug":"锁","link":"#锁","children":[]},{"level":2,"title":"SQL调优","slug":"sql调优","link":"#sql调优","children":[]},{"level":2,"title":"分库分表","slug":"分库分表","link":"#分库分表","children":[]},{"level":2,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[]},{"level":2,"title":"MySQL架构","slug":"mysql架构","link":"#mysql架构","children":[]},{"level":2,"title":"数据库连接池","slug":"数据库连接池","link":"#数据库连接池","children":[]}],"git":{},"readingTime":{"minutes":28.14,"words":8441},"filePathRelative":"java/MySQL.md","localizedDate":"August 8, 2023","excerpt":"<h1> MySQL</h1>\\n<h2> 基础</h2>\\n<ul>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">1. 数据库的三范式是什么？</a></p>\\n<ul>\\n<li>第一范式：列不可拆分，即原子性</li>\\n<li>第二范式：行记录唯一，即唯一性</li>\\n<li>第三范式：不可派生，即如果两个列通过计算可以得到第三列，那么不需要设置第三列。</li>\\n<li>备注：第三范式已经过时，有时候为了效率多设置一个列，可以牺牲第三范式，达到空间换时间的目的</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_2-mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">2. MySQL 支持哪些存储引擎?</a></p>\\n<ul>\\n<li>说说常见的innodb和myisam吧，说说他们的区别</li>\\n<li>区别：\\n<ul>\\n<li>innodb支持事务、主键、外键，myisam不支持</li>\\n<li>innodb支持行级锁和表级锁，而myisam只支持表级锁</li>\\n<li>myisam内部有存储表行数的变量，而innodb没有</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">3. 超键、候选键、主键、外键分别是什么？</a></p>\\n<ul>\\n<li>不背</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_4-sql-%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">4. SQL 约束有哪几种？</a></p>\\n<ul>\\n<li>NotNull，unique，主键，外键，check</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_5-mysql-%E4%B8%AD%E7%9A%84-varchar-%E5%92%8C-char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">5. MySQL 中的 varchar 和 char 有什么区别？</a></p>\\n<ul>\\n<li>char是定长的字符，比如我们申请了char(10),无论插入多长数据都占用10个字符、</li>\\n<li>varchar是可变长的字符，数字代表的是最大字符数，实际占用是实际长度+1，最后一个字符记录的是字符长度</li>\\n<li>速度上看，char&gt;varchar。</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_6-mysql%E4%B8%AD-in-%E5%92%8C-exists-%E5%8C%BA%E5%88%AB\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">6. MySQL中 in 和 exists 区别</a></p>\\n<ul>\\n<li>暂时不背</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_7-drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">7. drop、delete与truncate的区别</a></p>\\n<ul>\\n<li>delete是DML语言，所以支持事务，drop和truncate是DDL语言，语句不支持事务</li>\\n<li>drop是删除整张表，truncate删除全部数据，不删除表结构，而delete可以删除部分数据。</li>\\n<li>速度上看，drop&gt;truncate&gt;delete</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_8-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">8. 什么是存储过程？有哪些优缺点？</a></p>\\n<ul>\\n<li>预编译的SQL语句</li>\\n<li>但不推荐使用，不好维护和迁移</li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\"https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_9-mysql-%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">9. MySQL 执行查询的过程</a></p>\\n<ul>\\n<li>客户端TCP链接到连接器，这个阶段会做身份校验和资源分配</li>\\n<li>查缓存</li>\\n<li>语法分析，检查SQL语句是否写错了，表和表数据是否存在，别名是否有歧义等</li>\\n<li>优化，是否使用了索引</li>\\n<li>执行器执行，把结果集查询出来然后保存到缓存</li>\\n</ul>\\n</li>\\n<li>\\n<ol start=\\"10\\">\\n<li>MySQL常用的函数有哪些</li>\\n</ol>\\n<ul>\\n<li>avg()平均数</li>\\n<li>sum()总数</li>\\n<li>max()最大</li>\\n<li>min()最小</li>\\n<li>abs() 绝对值</li>\\n<li>concat('a','b')</li>\\n<li>replace(str,old,new)</li>\\n</ul>\\n</li>\\n<li>\\n<p>查询语句不同元素执行先后顺序？</p>\\n<ul>\\n<li>where</li>\\n<li>group by</li>\\n<li>having</li>\\n<li>select</li>\\n<li>distinct</li>\\n<li>order by</li>\\n<li>limit</li>\\n</ul>\\n</li>\\n<li>\\n<p>count 性能哪种更好</p>\\n<ul>\\n<li>count(*) = count(1) &gt; count(主键) &gt; count （字段）</li>\\n<li>count(1) :\\n<ul>\\n<li>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引。</li>\\n<li>如果有二级索引，就遍历二级索引。</li>\\n</ul>\\n</li>\\n<li>count(<code>*</code>)\\n<ul>\\n<li>其实等于 count(<code>0</code>)，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。</li>\\n<li>count(*) 执行过程跟 count(1) 执行过程基本一样的</li>\\n</ul>\\n</li>\\n<li>count(主键)\\n<ul>\\n<li>如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引。</li>\\n<li>如果有二级索引，就遍历二级索引。</li>\\n</ul>\\n</li>\\n<li>count(普通字段)\\n<ul>\\n<li>全表扫描，最慢</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>having和where 有什么区别</p>\\n<ul>\\n<li>where是在结果集返回之前的过滤，having是在结果集返回之后的过滤。</li>\\n<li>having通常配合group by一起使用，用于分组后的过滤</li>\\n<li>where 不能使用聚合函数以及聚合函数的别名，having可以\\n<ul>\\n<li>select goods_category_id , avg(goods_price) as ag from sw_goods group by goods_category having ag &gt; 1000</li>\\n<li>select goods_category_id , avg(goods_price) as ag from sw_goods where ag&gt;1000 group by goods_category //报错！！因为from sw_goods 这张数据表里面没有ag这个字段</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>union 和 union all 有什么区别</p>\\n<ul>\\n<li>union 对于重复的记录会去重，union all不会</li>\\n<li>union默认会按照字段的顺序排序，union all 不会</li>\\n<li>结论：UNION去重且排序，UNION ALL不去重不排序</li>\\n</ul>\\n</li>\\n<li>\\n<p>left join ，right join，inner join的区别</p>\\n<ul>\\n<li>left join 返回左表的所有记录和右边匹配到的记录</li>\\n<li>right join 返回右表的所有记录和左表匹配到的记录</li>\\n<li>inner join 返回左右两张表共同匹配的部分</li>\\n</ul>\\n</li>\\n<li>\\n<p>TIMESTAMP 与 DATETIME 的区别</p>\\n<ul>\\n<li>相同点：\\n<ul>\\n<li>TIMESTAMP 列的显示格式与 DATETIME 列相同。格式为YYYY-MM-DD HH:MM:SS。</li>\\n</ul>\\n</li>\\n<li>不同点：\\n<ul>\\n<li>TIMESTAMP：\\n<ul>\\n<li>4个字节存储，时间范围：1970-01-01 08:00:01~2038-01-19 11:14:07</li>\\n<li>值以UTC格式保存，涉及时区转化，存储时对当前的时区进行转换，检索时再转换回当前的时区</li>\\n</ul>\\n</li>\\n<li>DATETIME\\n<ul>\\n<li>8个字节存储，时间范围：1000-10-01 00:00:00~9999-12-31 23:59:59</li>\\n<li>实际格式存储，与时区无关</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{n as data};
